

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AMP CSV Anomaly + Curve Diagnostics — v3.2 Release</title>
<style>
  :root{
    --bg0:#0b1220; --bg1:#0f1b2e; --card:#0f2234cc; --card2:#0b1a2b;
    --txt:#e6eef7; --mut:#9bb0c8; --line:#1f3550;
    --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --mid:#38bdf8; --hi:#a78bfa;
  }
  *{box-sizing:border-box}
  body{
    margin:0; color:var(--txt); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background:
      radial-gradient(1100px 600px at 20% -10%, rgba(56,189,248,.18), transparent 60%),
      radial-gradient(1000px 600px at 85% 0%, rgba(167,139,250,.14), transparent 55%),
      linear-gradient(180deg, var(--bg0), #050914);
    min-height:100vh;
  }
  header{
    padding:18px 18px 10px;
    display:flex; gap:12px; align-items:flex-end; justify-content:space-between;
  }
  header h1{margin:0; font-size:18px; letter-spacing:.2px}
  header .sub{margin:2px 0 0; color:var(--mut); font-size:12px}
  header .right{display:flex; gap:10px; align-items:center}
  .pill{
    font-size:12px; color:var(--mut); border:1px solid var(--line); padding:6px 10px; border-radius:999px;
    background:rgba(15,34,52,.55);
  }
  main{display:grid; grid-template-columns: 340px 1fr; gap:14px; padding:0 14px 16px;}
  .card{
    border:1px solid rgba(31,53,80,.7);
    background: linear-gradient(180deg, rgba(15,34,52,.72), rgba(11,26,43,.62));
    box-shadow: 0 12px 30px rgba(0,0,0,.25);
    border-radius:16px;
    overflow:hidden;
  }
  .card h2{margin:0; padding:12px 14px; font-size:13px; letter-spacing:.2px; border-bottom:1px solid rgba(31,53,80,.6); color:#d8e6f8}
  .card .body{padding:12px 14px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .btn{
    background:#12314c; border:1px solid rgba(56,189,248,.35);
    color:var(--txt); padding:8px 10px; border-radius:12px; cursor:pointer; font-weight:600; font-size:12px;
  }
  .btn:hover{filter:brightness(1.08)}
  .btn.secondary{background:transparent; border:1px solid rgba(31,53,80,.9); color:var(--mut)}
  input[type="file"]{display:none}
  .drop{
    border:1px dashed rgba(56,189,248,.45);
    border-radius:14px; padding:12px; background:rgba(3,11,22,.35);
    color:var(--mut); font-size:12px;
  }
  .drop strong{color:var(--txt)}
  .kv{display:grid; grid-template-columns: 1fr auto; gap:6px 10px; margin-top:10px; font-size:12px}
  .kv div:nth-child(odd){color:var(--mut)}
  .kv div:nth-child(even){font-variant-numeric: tabular-nums;}
  .control{margin-top:10px}
  label{font-size:12px; color:var(--mut)}
  input[type="range"]{width:100%}
  select, input[type="text"]{
    width:100%;
    background:rgba(3,11,22,.5);
    border:1px solid rgba(31,53,80,.85);
    color:var(--txt);
    padding:9px 10px; border-radius:12px; outline:none;
  }
  select:focus, input[type="text"]:focus{border-color:rgba(56,189,248,.65)}
  .hint{font-size:12px; color:var(--mut); line-height:1.35}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
  .split{display:flex; gap:10px}
  .split > *{flex:1}
  .tog{display:flex; align-items:center; gap:8px; margin-top:8px; font-size:12px; color:var(--mut)}
  .tog input{transform: translateY(1px)}
  .badges{display:flex; gap:6px; flex-wrap:wrap}
  .badge{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border-radius:999px; font-size:11px; border:1px solid rgba(31,53,80,.8);
    background:rgba(3,11,22,.35); color:var(--mut);
  }
  .dot{width:8px; height:8px; border-radius:999px; display:inline-block}
  .dot.good{background:var(--good)}
  .dot.mid{background:var(--mid)}
  .dot.hi{background:var(--hi)}
  .dot.warn{background:var(--warn)}
  .dot.bad{background:var(--bad)}
  /* Right side table */
  .tableWrap{overflow:auto; overflow-x:auto; max-height: calc(100vh - 120px);}
  .tableWrap table{min-width: 1400px;}
  table{width:100%; border-collapse:separate; border-spacing:0; font-size:12px}
  thead th{
    position:sticky; top:0; z-index:2;
    background:rgba(9,20,34,.95);
    border-bottom:1px solid rgba(31,53,80,.9);
    padding:10px 10px; text-align:left; color:#cfe1f5; font-weight:700;
    white-space:nowrap;
  }
  tbody td{
    border-bottom:1px solid rgba(31,53,80,.35);
    padding:8px 10px; vertical-align:middle;
  }
  tbody tr:hover{background:rgba(56,189,248,.06)}
  tbody tr.selected{outline:2px solid rgba(124,220,255,.55); outline-offset:-2px; background:rgba(124,220,255,.10)}
  tbody tr.normal{background:transparent}
  tbody tr.moderate{background:rgba(56,189,248,.06)}
  tbody tr.high{background:rgba(245,158,11,.08)}
  tbody tr.flyer{background:rgba(239,68,68,.10)}
  .sessionBar{
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    padding:10px 14px; border-bottom:1px solid rgba(31,53,80,.6);
  }
  .sessionPill{
    display:flex; align-items:center; gap:8px;
    border:1px solid rgba(31,53,80,.85);
    background:rgba(3,11,22,.35);
    padding:8px 10px; border-radius:999px; max-width:100%;
    min-width:0;
  }
  .sessionPill .label{
    min-width:0; max-width:100%;
    overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    font-size:12px; color:var(--txt); font-weight:700;
  }
  .sessionPill .meta{font-size:11px; color:var(--mut); white-space:nowrap}
  .chip{
    font-size:11px; color:var(--mut); border:1px solid rgba(31,53,80,.8);
    padding:4px 8px; border-radius:999px; background:rgba(3,11,22,.25);
  }
  .warnBox{
    margin:12px 14px; padding:12px; border-radius:14px;
    border:1px solid rgba(245,158,11,.35);
    background:rgba(245,158,11,.08); color:#f7d9a5;
  }
  .kbd{font-family:ui-monospace; font-size:11px; padding:1px 6px; border:1px solid rgba(31,53,80,.9); border-radius:6px; background:rgba(3,11,22,.35); color:var(--mut)}
  .small{font-size:11px; color:var(--mut)}
  .nowrap{white-space:nowrap}

/* v2.1 patches */
.control select{max-width:100%; width:100%;}
.sessionPill .label{min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:block;}
tr.excluded{opacity:.55;}
.viewTabs{display:flex; gap:8px; align-items:center;}
.viewTabs .tabbtn{padding:7px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:var(--txt); cursor:pointer; font-weight:600;}
.viewTabs .tabbtn.active{background:rgba(124,220,255,.18); border-color:rgba(124,220,255,.35);}
.sessionsWrap{display:none;}
.sessionsWrap table{width:100%; border-collapse:separate; border-spacing:0 10px;}
.sessionsWrap th{font-size:12px; color:var(--mut); text-align:left; padding:0 10px;}
.sessionsWrap td{padding:10px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08);}
.sessionsWrap tr:hover td{background:rgba(255,255,255,.06); cursor:pointer;}


  th.sortedAsc::after{content:' ▲'; opacity:.7;}
  th.sortedDesc::after{content:' ▼'; opacity:.7;}

.tableWrap{ overflow:auto; }
.tableWrap table{ min-width: 1200px; }
.tableWrap thead th:nth-child(1),
.tableWrap tbody td:nth-child(1){
  position: sticky; left: 0; 
  min-width:120px; width:120px;
}
.tableWrap thead th:nth-child(1){ z-index: 7; background: rgba(10,16,28,.98); }
.tableWrap tbody td:nth-child(1){ z-index: 4; background: rgba(8,12,18,.96); }

.tableWrap thead th:nth-child(2),
.tableWrap tbody td:nth-child(2){
  position: sticky; left: 120px;
  min-width:90px; width:90px;
}
.tableWrap thead th:nth-child(2){ z-index: 7; background: rgba(10,16,28,.98); }
.tableWrap tbody td:nth-child(2){ z-index: 4; background: rgba(8,12,18,.96); }

.tableWrap thead th:nth-child(3),
.tableWrap tbody td:nth-child(3){
  position: sticky; left: 210px;
  min-width:110px; width:110px;
}
.tableWrap thead th:nth-child(3){ z-index: 7; background: rgba(10,16,28,.98); }
.tableWrap tbody td:nth-child(3){ z-index: 4; background: rgba(8,12,18,.96); }

/* subtle divider after pinned columns */
.tableWrap thead th:nth-child(3),
.tableWrap tbody td:nth-child(3){
  box-shadow: 8px 0 18px rgba(0,0,0,.22);
}
.tableWrap tbody tr.excluded td:first-child{
  background: rgba(10,16,28,.92);
}

/* ===== Suite header + NodeLab-like theme (shared kit) ===== */
:root{
  --suite-bg0: rgb(17,22,27);
  --suite-bg1: rgb(25,33,40);
  --suite-panel0: rgb(34,42,55);
  --suite-panel1: rgb(25,33,40);

  --suite-text: rgb(223,230,236);
  --suite-muted: rgb(149,166,178);
  --suite-faint: rgb(101,109,112);

  --suite-border: rgba(255,255,255,.10);
  --suite-border2: rgba(255,255,255,.06);

  --suite-shadow: 0 18px 50px rgba(0,0,0,.45);
  --suite-shadow2: 0 10px 22px rgba(0,0,0,.35);

  --suite-r-lg: 28px;
}

/* background + text */
body{
  background:
    radial-gradient(1200px 600px at 20% 0%, rgba(52,66,85,.55), transparent 60%),
    radial-gradient(900px 520px at 90% 10%, rgba(34,42,55,.55), transparent 55%),
    linear-gradient(180deg, var(--suite-bg1), var(--suite-bg0));
  color: var(--suite-text);
}


.suiteHeader__badge--img{ position:relative; overflow:hidden; padding:0; }
.suiteHeader__badge--img img{ width:100%; height:100%; object-fit:cover; display:block; filter: contrast(1.02) saturate(1.02); }
.suiteHeader__badgeText{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:800; letter-spacing:.4px; color: rgba(154,169,180,.75); }

/* NodeLab-style header */
.suiteHeader{
  display:flex; align-items:center; justify-content:space-between; gap:14px;
  padding: 12px 16px;
  border-radius: var(--suite-r-lg);
  border: 1px solid var(--suite-border);
  box-shadow: var(--suite-shadow);
  background: linear-gradient(135deg, rgba(34,42,55,.65), rgba(25,33,40,.55));
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  margin: 12px 12px 16px;
}

.suiteHeader__topline{ display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
.suiteHeader__title{ font-size: 30px; font-weight: 760; letter-spacing: .2px; }
.suiteHeader__pill{
  font-size: 14px; padding: 4px 10px; border-radius: 999px;
  border: 1px solid var(--suite-border2);
  background: rgba(0,0,0,.18);
  color: var(--suite-muted);
}
.suiteHeader__pill--muted{ opacity:.85; }
.suiteHeader__tagline{ margin-top: 6px; color: var(--suite-muted); font-size: 15px; line-height: 1.25; }

.suiteHeader__right{ display:flex; align-items:center; gap:12px; }
.suiteHeader__actions{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
.suiteHeader__badge{
  width: 52px; height: 52px; border-radius: 999px;
  border: 1px solid var(--suite-border);
  background: radial-gradient(circle at 30% 30%, rgba(223,230,236,.12), rgba(0,0,0,.2));
  box-shadow: var(--suite-shadow2);
  display:flex; align-items:center; justify-content:center;
  color: var(--suite-faint);
  font-weight: 800;
  letter-spacing: .6px;
}

/* keep your existing layout, but stop using the old <header> rules */
header h1, header .sub, header .right{ all: unset; }

/* responsive: stack header content on small screens */
@media (max-width: 820px){
  .suiteHeader{ flex-direction:column; align-items:stretch; }
  .suiteHeader__right{ justify-content:space-between; }
  .suiteHeader__title{ font-size: 28px; }
  .suiteHeader__tagline{ font-size: 16px; }
}

header{padding:0; display:block; gap:0; align-items:unset; justify-content:unset;}
</style>
</head>
<body>
<header class="suiteHeader">
  <div class="suiteHeader__left">
    <div class="suiteHeader__topline">
      <div class="suiteHeader__title">AMP Anomaly Finder</div>
      <div class="suiteHeader__pill">v3.2</div>
      <div class="suiteHeader__pill suiteHeader__pill--muted">offline</div>
    </div>
    <div class="suiteHeader__tagline">Upload AMP “Press” CSV exports (wide). Scores anomalies + adds curve diagnostics (early spike, jaggedness, end flat/drop) when curve data exists.</div>
  </div>

  <div class="suiteHeader__right">
    <div class="suiteHeader__actions">
      <button class="btn secondary" id="btnExport">Export shown (CSV)</button>
      
      <button class="btn secondary" id="btnExportJSON" title="Export loaded sessions + baseline + settings as JSON">Export .json</button>
      <button class="btn secondary" id="btnImportJSON" title="Import a previously exported JSON package">Import .json</button>
      <input id="jsonIn" type="file" accept=".json,application/json" style="display:none" />
<button class="btn secondary" id="btnCopy" title="Copy the currently shown table rows as CSV to clipboard">Copy shown</button>
      <button class="btn secondary" id="btnClearSort" title="Clear header-click sort (revert to Sort dropdown)">Clear sort</button>
      <button class="btn secondary" id="btnReset" title="Restore default view settings">Reset defaults</button>
      <button class="btn secondary" id="btnClear">Clear</button>
    </div>
    <div class="suiteHeader__badge suiteHeader__badge--img" title="Target"><img src="data:image/jpeg;base64,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" alt="Target"><span class="suiteHeader__badgeText">AMP</span></div>
  </div>
</header>

<main>
  <section class="card">
    <h2>Upload & Controls</h2>
    <div class="body">
      <div class="row">
        <label class="btn" for="fileIn">Choose files</label>
        <input id="fileIn" type="file" accept=".csv,text/csv" multiple/>
      </div>

      <div id="drop" class="drop" style="margin-top:10px">
        <strong>Drop AMP CSV files here</strong><br/>
        <span class="small">Each file becomes a session. Works offline (no internet needed).</span>
      </div>

      <div class="control" style="margin-top:12px">
        <label>Session</label>
        <select id="sessionSel"></select>
        <div class="hint" style="margin-top:6px">
          Tip: AMP export is often <span class="mono">wide</span> (variables in rows, <span class="mono">Trace 1..N</span> in columns). This tool expects that.
        </div>
      </div>

      <div class="control">
        <label>Anomaly threshold: <span class="mono" id="thVal">2.50</span></label>
        <input id="th" type="range" min="0.5" max="5.0" step="0.05" value="2.5"/>
        <div class="tog"><input id="onlyAnom" type="checkbox"/><label for="onlyAnom">Only anomalies</label></div>
        <div class="tog"><input id="onlyActionable" type="checkbox"/><label for="onlyActionable" title="Shows Score ≥ threshold OR Flyer OR Excluded">Only actionable</label></div>
      
      <div class="control">
        <label>Peak Force ES limit (lb): <span class="mono" id="esVal">20</span></label>
        <input id="es" type="range" min="5" max="50" step="1" value="20"/>
        <div class="tog"><input id="esAuto" type="checkbox" checked/><label for="esAuto">Auto-exclude ES extremes (top/bottom) when limit exceeded</label></div>
        <div class="hint" style="margin-top:6px">
          ES here is <span class="mono">max(peak)-min(peak)</span> for the session. If it exceeds the limit, the max and min traces are marked <span class="mono">Excluded</span> but remain visible for learning.
        </div>
      </div>

      <div class="control">
        <div class="tog"><input id="hideEx" type="checkbox"/><label for="hideEx">Hide excluded rounds</label></div>
      </div>
</div>

      <div class="control">
        <label>Search</label>
        <input id="q" type="text" placeholder="trace, driver, cause…"/>
      </div>

      <div class="control">
        <div class="split">
          <div>
            <label>Sort</label>
            <select id="sortSel">
              <option value="custom">Custom (header click)</option>
              <option value="score_desc">Score (high → low)</option>
              <option value="score_asc">Score (low → high)</option>
              <option value="trace_asc">Trace (asc)</option>
              <option value="trace_desc">Trace (desc)</option>
              <option value="peak_desc">Peak Force (high → low)</option>
              <option value="work_desc">Work Done (high → low)</option>
              <option value="rough_desc">Roughness (high → low)</option>
            </select>
          </div>
          <div>
            <label>Baseline</label>
            <select id="baseSel">
              <option value="none">No baseline</option>
              <option value="active">Active session</option>
              <option value="custom">Saved baseline</option>
            </select>
            <div class="row" style="margin-top:8px">
              <button class="btn secondary" id="btnSaveBase" title="Save the active session medians as baseline">Save baseline</button>
              <button class="btn secondary" id="btnClrBase" title="Clear saved baseline">Clear</button>
            </div>
          </div>
        </div>
        <div class="hint" style="margin-top:8px">
          Baseline enables “Steeper slope overall” style detection by comparing session medians to your baseline.
        </div>
      </div>

      <div class="control">
        <div class="kv">
          <div>Rounds</div><div class="mono" id="kN">—</div>
          <div>Anomalies (≥ threshold)</div><div class="mono" id="kA">—</div>
          <div>Peak Force median</div><div class="mono" id="kPF">—</div>
          <div>Curve data</div><div class="mono" id="kCurve">—</div>
        </div>
      </div>

      <div class="control">
        <div class="badges">
          <span class="badge"><span class="dot good"></span> Normal</span>
          <span class="badge"><span class="dot mid"></span> Moderate</span>
          <span class="badge"><span class="dot warn"></span> High</span>
          <span class="badge"><span class="dot bad"></span> Flyer</span>
        </div>
      </div>

      <div class="control" style="margin-top:12px">
        <details>
          <summary class="hint">What diagnostics mean (click)</summary>
          <div class="hint" style="margin-top:8px">
            <div><b>Early Spike</b>: unusually high force early in the seating stroke → often chamfer/case mouth/donut.</div>
            <div><b>Jagged</b>: high “roughness” (curve jitter) → carbon/corrosion/neck-wall inconsistency.</div>
            <div><b>End Flat/Drop</b>: unusually flat or dropping end segment → bearing-surface transition; if inconsistent, investigate setup/components.</div>
            <div><b>Force Outlier</b>: Peak/Work/Terminal unusually high/low → neck tension / sizing / anneal variance.</div>
          </div>
        </details>
      </div>

      <div class="warnBox" style="display:none" id="injWarn">
        <b>Heads up:</b> Your browser appears to have a script/extension injecting ad/redirect code into pages.
        This tool runs offline and does not load remote URLs. If you see network calls to random domains, try Incognito or remove the extension.
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Rounds</h2>
    <div class="sessionBar">
      <div class="sessionPill" style="flex:1">
        <span class="chip">Session</span>
        <span class="label" id="sessLabel" title="—">—</span>
        <span class="meta" id="sessMeta">—</span>
      </div>
      <div class="viewTabs" style="margin-left:auto">
        <button class="tabbtn active" id="tabRounds" type="button">Rounds</button>
        <button class="tabbtn" id="tabSessions" type="button">Sessions</button>
      </div>
      <span class="chip" id="curveChip">Curve: —</span>
      <span class="chip" id="baseChip">Baseline: none</span>
      <span class="chip" id="showChip">Shown: —</span>
      <span class="chip" id="filterChip" style="display:none">Filters: —</span>
    </div>

    <div id="empty" class="warnBox">
      Upload one or more AMP CSV files to see a scored table here.
      <div class="hint">If your AMP export layout is different, paste a few header lines and I’ll adapt the parser.</div>
    </div>

    <div class="tableWrap" id="tableWrap" style="display:none">

      <div class="card" id="traceChartCard" style="margin-bottom:12px">
        <div class="row" style="justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap">
          <div>
            <div class="kTitle">Trace chart</div>
            <div class="hint">Peak Force by trace index. Highlights: <span class="mono">Flyer</span>, <span class="mono">Top5</span>/<span class="mono">Bottom5</span>, and <span class="mono">Excluded</span>.</div>
          </div>
          <div class="row" style="gap:10px; flex-wrap:wrap; justify-content:flex-end">
            <label class="row small" style="gap:6px; cursor:pointer"><input type="checkbox" id="tcOverlayWork"/> Overlay Work Done</label>
            <label class="row small" style="gap:6px; cursor:pointer"><input type="checkbox" id="tcUseFiltered"/> Use filtered view</label>
            <label class="row small" style="gap:6px; cursor:pointer"><input type="checkbox" id="tcShowExcluded" checked/> Show excluded</label>
          </div>
        </div>
        <div class="card" style="margin-top:10px; padding:10px; background:rgba(0,0,0,.12)">
          <canvas id="traceChart" width="900" height="240" style="width:100%; height:240px"></canvas>
          <div class="hint" style="margin-top:6px">Tip: click column headers to sort; chart updates for the active session.</div>
        </div>
      </div>

      <table>
        <thead>
          <tr>
            <th>Trace</th>
            <th>Flyer</th>
            <th>Excluded</th>
            <th>Tag</th>
            <th>Why</th>
            <th>Cause</th>
            <th>Conf</th>
            <th>Score</th>
            <th>Driver</th>
            <th class="nowrap">Peak Force</th>
            <th class="nowrap">Work Done</th>
            <th class="nowrap">Starting Pos</th>
            <th class="nowrap">Terminal Force</th>
            <th class="nowrap">Early Spike</th>
            <th class="nowrap">Jagged</th>
            <th class="nowrap">End Flat</th>
            <th class="nowrap">End Drop</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <div class="sessionsWrap" id="sessionsWrap">
      <div class="row" style="justify-content:space-between; align-items:center; margin:6px 0 10px">
        <div class="small">Session summary across all loaded files. Click a session row to jump back to its rounds.</div>
        <button class="btn secondary" id="btnExportSessions" type="button" title="Export session summary CSV">Export sessions (CSV)</button>
      </div>
      <div class="card" style="padding:10px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08); border-radius:14px; margin-bottom:12px">
        <canvas id="sessChart" width="900" height="220" style="width:100%; height:220px"></canvas>
        <div class="hint" style="margin-top:6px">Two lines: <span class="mono">Peak Med</span> (median Peak Force) and <span class="mono">Peak ES</span>. Each vertex is a loaded session, in session order.</div>
      </div>
      <table>
        <thead>
          <tr>
            <th>Session</th>
            <th>Rounds</th>
            <th>Flyers</th>
            <th>Anomalies</th>
            <th>Peak Med</th>
            <th>Peak ES</th>
            <th>Work Med</th>
            <th>Rough Med</th>
          </tr>
        </thead>
        <tbody id="sessionsTbody"></tbody>
      </table>
    </div>
    


  </section>
</main>

<script>
/* ========== small safety nudge (detect injected network calls via global fetch patch check) ========== */
(function(){
  try{
    // If some extension overwrote fetch in a weird way, it might show as non-native.
    const f = window.fetch;
    const looksNative = f && (String(f).includes('[native code]') || String(f).includes('function fetch'));
    // Not a definitive check; we only display if we already see suspicious error patterns later.
    window.__fetchLooksNative = looksNative;
  }catch(e){}
})();

/* ========== state ========== */
const state = {
  sessions: [],
  activeIndex: 0,
  threshold: 2.5,
  esLimit: 20,
  esAutoExclude: true,
  hideExcluded: false,
  view: 'rounds',
  onlyAnom: false,
  onlyActionable: false,
  query: "",
  sort: "score_desc",
  baselineMode: "none", // none|active|custom
  baseline: null, // {metrics:{key:{med}}, curves:{key:{med}}}
  traceChart: { overlayWork:false, useFiltered:false, showExcluded:true },
  shownRows: [],
  selectedRowIdx: -1,
  shotLedger: null,
  corr: { points: [], hoverIdx: -1 },
  tcPoints: [],

};


/* ========== settings persistence (Phase 2) ========== */
const SETTINGS_KEY = 'amp_anomaly_finder_settings_v1';
const DEFAULTS = Object.freeze({
  threshold: 2.5,
  esLimit: 20,
  esAutoExclude: true,
  hideExcluded: false,
  onlyAnom: false,
  onlyActionable: false,
  query: '',
  sort: 'score_desc',
  baselineMode: 'none'
});


const BUILD_TAG = "v3.10-phase8-json";

function exportPreambleLines(kind){
  const sess = (typeof getActiveSession === 'function') ? getActiveSession() : null;
  const lines = [];
  const now = new Date();
  lines.push(`# amp_anomaly_finder_export=${kind}`);
  lines.push(`# build=${BUILD_TAG}`);
  lines.push(`# exported_at=${now.toISOString()}`);
  lines.push(`# threshold=${Number(state.threshold).toFixed(2)}`);
  lines.push(`# esLimit=${Number(state.esLimit)}`);
  lines.push(`# esAutoExclude=${!!state.esAutoExclude}`);
  lines.push(`# hideExcluded=${!!state.hideExcluded}`);
  lines.push(`# onlyAnom=${!!state.onlyAnom}`);
  lines.push(`# onlyActionable=${!!state.onlyActionable}`);
  lines.push(`# query=${(state.q||"").replace(/\s+/g,' ').trim()}`);
  lines.push(`# sort=${String(state.sort||"custom")}`);
  lines.push(`# baselineMode=${String(state.baselineMode||"none")}`);
  if(sess && sess.name) lines.push(`# activeSession=${String(sess.name)}`);
  return lines;
}

function downloadTextFile(filename, text, mime){
  const blob = new Blob([text], {type: mime || "text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 500);
}

function buildJSONPackage(){
  // Keep this focused: sessions + baseline + core settings needed to reproduce a view
  const pkg = {
    schema: "amp_anomaly_finder_json",
    version: 1,
    build: BUILD_TAG,
    exportedAt: new Date().toISOString(),
    settings: {
      threshold: state.threshold,
      esLimit: state.esLimit,
      esAutoExclude: state.esAutoExclude,
      hideExcluded: state.hideExcluded,
      onlyAnom: state.onlyAnom,
      onlyActionable: state.onlyActionable,
      query: state.query,
      sort: state.sort,
      baselineMode: state.baselineMode
    },
    data: {
      activeIndex: state.activeIndex,
      baseline: state.baseline || null,
      sessions: state.sessions || []
    }
  };
  return pkg;
}

function exportJSON(){
  const pkg = buildJSONPackage();
  const niceName = (state.sessions && state.sessions.length===1)
    ? (state.sessions[0].name || "session")
    : "amp_sessions";
  const fn = `${niceName}_AMP_Anomaly_Finder.json`.replace(/[^a-zA-Z0-9._-]+/g,'_');
  downloadTextFile(fn, JSON.stringify(pkg, null, 2), "application/json");
}

function applyImportedSettings(s){
  if(!s) return;
  // apply to state first
  if(typeof s.threshold === "number") state.threshold = s.threshold;
  if(typeof s.esLimit === "number") state.esLimit = s.esLimit;
  if(typeof s.esAutoExclude === "boolean") state.esAutoExclude = s.esAutoExclude;
  if(typeof s.hideExcluded === "boolean") state.hideExcluded = s.hideExcluded;
  if(typeof s.onlyAnom === "boolean") state.onlyAnom = s.onlyAnom;
  if(typeof s.onlyActionable === "boolean") state.onlyActionable = s.onlyActionable;
  if(typeof s.query === "string") state.query = s.query;
  if(typeof s.sort === "string") state.sort = s.sort;
  if(typeof s.baselineMode === "string") state.baselineMode = s.baselineMode;

  // sync UI controls (guard if element missing in older builds)
  if(els.th) els.th.value = state.threshold;
  if(els.thVal) els.thVal.textContent = state.threshold.toFixed(2);
  if(els.es) els.es.value = state.esLimit;
  if(els.esVal) els.esVal.textContent = String(state.esLimit);
  if(els.esAuto) els.esAuto.checked = !!state.esAutoExclude;
  if(els.hideEx) els.hideEx.checked = !!state.hideExcluded;
  if(els.onlyAnom) els.onlyAnom.checked = !!state.onlyAnom;
  if(els.onlyActionable) els.onlyActionable.checked = !!state.onlyActionable;
  if(els.q) els.q.value = state.query || "";
  if(els.sortSel) els.sortSel.value = state.sort || "score_desc";
  if(els.baseSel) els.baseSel.value = state.baselineMode || "none";
}

function importJSONText(text){
  let pkg;
  try{
    pkg = JSON.parse(text);
  }catch(e){
    alert("Invalid JSON file.");
    return;
  }
  if(!pkg || pkg.schema !== "amp_anomaly_finder_json"){
    alert("This JSON doesn't look like an AMP Anomaly Finder export.");
    return;
  }
  if(pkg.version !== 1){
    alert("Unsupported JSON export version: " + pkg.version);
    return;
  }

  // data restore
  const data = pkg.data || {};
  if(Array.isArray(data.sessions)){
    state.sessions = data.sessions;
  }else{
    state.sessions = [];
  }
  state.activeIndex = Math.max(0, Math.min((data.activeIndex||0), Math.max(0, state.sessions.length-1)));
  state.baseline = data.baseline || null;

  // settings restore
  applyImportedSettings(pkg.settings || null);

  // post-load safety: normalize derived fields if missing
  // (older exports or hand-edited JSON)
  for(const sess of (state.sessions||[])){
    if(!sess || !Array.isArray(sess.rounds)) continue;
    // ensure name exists
    if(!sess.name) sess.name = sess.filename || "Imported session";
    // recompute tags/exclusions if function exists
    if(typeof recomputeSessionPostFlags === "function"){
      try{ recomputeSessionPostFlags(sess); }catch(e){}
    }
  }

  // refresh UI
  if(typeof renderSessionOptions === "function") renderSessionOptions();
  saveSettings();
  render();
}





function loadSettings(){
  try{
    const raw = localStorage.getItem(SETTINGS_KEY);
    if(!raw) return {...DEFAULTS};
    const parsed = JSON.parse(raw);
    return {...DEFAULTS, ...(parsed||{})};
  }catch(e){
    return {...DEFAULTS};
  }
}

function saveSettings(){
  try{
    const out = {
      threshold: Number(state.threshold),
      esLimit: Number(state.esLimit),
      esAutoExclude: !!state.esAutoExclude,
      hideExcluded: !!state.hideExcluded,
      onlyAnom: !!state.onlyAnom,
      onlyActionable: !!state.onlyActionable,
      query: String(state.query||''),
      sort: String(state.sort||DEFAULTS.sort),
      baselineMode: String(state.baselineMode||DEFAULTS.baselineMode)
    };
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(out));
  }catch(e){}
}

function applySettingsToStateAndUI(s){
  // State
  state.threshold = Number.isFinite(Number(s.threshold)) ? Number(s.threshold) : DEFAULTS.threshold;
  state.esLimit = Number.isFinite(Number(s.esLimit)) ? Number(s.esLimit) : DEFAULTS.esLimit;
  state.esAutoExclude = ('esAutoExclude' in s) ? !!s.esAutoExclude : DEFAULTS.esAutoExclude;
  state.hideExcluded = ('hideExcluded' in s) ? !!s.hideExcluded : DEFAULTS.hideExcluded;
  state.onlyAnom = ('onlyAnom' in s) ? !!s.onlyAnom : DEFAULTS.onlyAnom;
  state.onlyActionable = ('onlyActionable' in s) ? !!s.onlyActionable : DEFAULTS.onlyActionable;
  state.query = (typeof s.query === 'string') ? s.query : DEFAULTS.query;
  state.sort = (typeof s.sort === 'string') ? s.sort : DEFAULTS.sort;
  state.baselineMode = (typeof s.baselineMode === 'string') ? s.baselineMode : DEFAULTS.baselineMode;

  // UI controls
  if(els.th){ els.th.value = String(state.threshold); els.thVal.textContent = state.threshold.toFixed(2); }
  if(els.es){ els.es.value = String(state.esLimit); els.esVal.textContent = String(state.esLimit); }
  if(els.esAuto){ els.esAuto.checked = !!state.esAutoExclude; }
  if(els.hideEx){ els.hideEx.checked = !!state.hideExcluded; }
  if(els.onlyAnom){ els.onlyAnom.checked = !!state.onlyAnom; }
  if(els.onlyActionable){ els.onlyActionable.checked = !!state.onlyActionable; }
  if(els.q){ els.q.value = state.query || ''; }

  // Sort: reset header sort unless custom is explicitly in play
  if(els.sortSel){
    if(state.sort === 'custom'){
      els.sortSel.value = 'custom';
    }else{
      els.sortSel.value = state.sort || DEFAULTS.sort;
      state.sortField = null;
      state.sortDir = null;
      document.querySelectorAll('th').forEach(x=>x.classList.remove('sortedAsc','sortedDesc'));
    }
  }

  if(els.baseSel){
    // allow only valid values
    const v = (state.baselineMode || 'none');
    els.baseSel.value = (['none','active','custom'].includes(v) ? v : 'none');
  }
}

function resetDefaults(){
  applySettingsToStateAndUI({...DEFAULTS});
  // do NOT clear saved baseline (that has its own buttons)
  saveSettings();
}


const els = {
  fileIn: document.getElementById('fileIn'),
  drop: document.getElementById('drop'),
  sessionSel: document.getElementById('sessionSel'),
  th: document.getElementById('th'),
  thVal: document.getElementById('thVal'),
  es: document.getElementById('es'),
  esVal: document.getElementById('esVal'),
  esAuto: document.getElementById('esAuto'),
  hideEx: document.getElementById('hideEx'),
  onlyAnom: document.getElementById('onlyAnom'),
  onlyActionable: document.getElementById('onlyActionable'),
  q: document.getElementById('q'),
  sortSel: document.getElementById('sortSel'),
  baseSel: document.getElementById('baseSel'),
  btnSaveBase: document.getElementById('btnSaveBase'),
  btnClrBase: document.getElementById('btnClrBase'),
  btnExport: document.getElementById('btnExport'),
  btnExportJSON: document.getElementById('btnExportJSON'),
  btnImportJSON: document.getElementById('btnImportJSON'),
  jsonIn: document.getElementById('jsonIn'),
  btnCopy: document.getElementById('btnCopy'),
  btnClearSort: document.getElementById('btnClearSort'),
  btnReset: document.getElementById('btnReset'),
  btnClear: document.getElementById('btnClear'),
  empty: document.getElementById('empty'),
  tableWrap: document.getElementById('tableWrap'),
  tbody: document.getElementById('tbody'),
  kN: document.getElementById('kN'),
  kA: document.getElementById('kA'),
  kPF: document.getElementById('kPF'),
  kCurve: document.getElementById('kCurve'),
  sessLabel: document.getElementById('sessLabel'),
  sessMeta: document.getElementById('sessMeta'),
  tabRounds: document.getElementById('tabRounds'),
  tabSessions: document.getElementById('tabSessions'),
  sessionsWrap: document.getElementById('sessionsWrap'),
  sessionsTbody: document.getElementById('sessionsTbody'),
  btnExportSessions: document.getElementById('btnExportSessions'),
  sessChart: document.getElementById('sessChart'),
  traceChart: document.getElementById('traceChart'),
  tcOverlayWork: document.getElementById('tcOverlayWork'),
  tcUseFiltered: document.getElementById('tcUseFiltered'),
  tcShowExcluded: document.getElementById('tcShowExcluded'),
  curveChip: document.getElementById('curveChip'),
  baseChip: document.getElementById('baseChip'),
  showChip: document.getElementById('showChip'),
  filterChip: document.getElementById('filterChip'),
  curveChip2: document.getElementById('curveChip'),
  injWarn: document.getElementById('injWarn'),

  tabCorr: document.getElementById('tabCorr'),
  corrWrap: document.getElementById('corrWrap'),
  corrFile: document.getElementById('corrFile'),
  corrJoin: document.getElementById('corrJoin'),
  btnCorrClear: document.getElementById('btnCorrClear'),
  corrChart: document.getElementById('corrChart'),
  corrTbody: document.getElementById('corrTbody'),
  corrStatus: document.getElementById('corrStatus'),
  corrStats: document.getElementById('corrStats'),
};

/* ========== utils ========== */
function toNum(x){
  if(x==null) return null;
  const s = String(x).trim().replace(/,/g,''); // tolerate thousands separators
  if(s==="") return null;
  const v = Number(s);
  return Number.isFinite(v) ? v : null;
}
function fmt(v, d=3){
  if(!Number.isFinite(v)) return "—";
  return Number(v).toFixed(d);
}

function strengthTier(az){
  az = Math.abs(Number(az)||0);
  if(az>=2.8) return 3;
  if(az>=2.2) return 2;
  if(az>=1.6) return 1;
  return 0;
}
function strengthGlyph(t){
  const n = Number(t)||0;
  return n<=0 ? "—" : "•".repeat(Math.min(3, Math.max(1,n)));
}
function median(arr){
  const a = arr.filter(v=>Number.isFinite(v)).slice().sort((x,y)=>x-y);
  const n = a.length;
  if(!n) return null;
  const mid = Math.floor(n/2);
  return n%2 ? a[mid] : (a[mid-1]+a[mid])/2;
}
function mad(arr, med){
  const dev = arr.filter(v=>Number.isFinite(v)).map(v=>Math.abs(v-med));
  return median(dev);
}
function mean(arr){
  const a = arr.filter(v=>Number.isFinite(v));
  if(!a.length) return null;
  return a.reduce((s,v)=>s+v,0)/a.length;
}
function stdev(arr){
  const mu = mean(arr);
  if(mu==null) return null;
  const a = arr.filter(v=>Number.isFinite(v));
  if(a.length<2) return null;
  const v = a.reduce((s,x)=>s+(x-mu)**2,0)/(a.length-1);
  return Math.sqrt(v);
}
function robustZ(x, st){
  // st: {med, mad, sd, mu}
  if(!Number.isFinite(x) || st.med==null) return 0;
  if(st.mad && st.mad>0) return 0.6745*(x-st.med)/st.mad;
  if(st.sd && st.sd>0 && st.mu!=null) return (x-st.mu)/st.sd;
  return 0;
}
function clsFromScore(score){
  if(score>=3.5) return "flyer";
  if(score>=2.5) return "high";
  if(score>=1.5) return "moderate";
  return "normal";
}
function escapeHtml(s){
  return String(s??"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}

function escapeAttr(s){ return escapeHtml(s).replace(/"/g,'&quot;'); }
function pickDot(bucket){
  if(bucket==="flyer") return "bad";
  if(bucket==="high") return "warn";
  if(bucket==="moderate") return "mid";
  return "good";
}

/* ========== CSV parser (handles quotes) ========== */
function parseCSV(text){
  // sniff delimiter (comma vs semicolon)
  const firstLine = (text.split(/\r?\n/).find(l=>l.trim().length) || "");
  const comma = (firstLine.match(/,/g)||[]).length;
  const semi  = (firstLine.match(/;/g)||[]).length;
  const delim = semi>comma ? ';' : ',';

  const rows = [];
  let row = [];
  let cur = "";
  let inQ = false;
  for(let i=0;i<text.length;i++){
    const ch = text[i];
    if(inQ){
      if(ch === '"'){
        const next = text[i+1];
        if(next === '"'){ cur+='"'; i++; }
        else inQ = false;
      } else cur += ch;
    } else {
      if(ch === '"') inQ = true;
      else if(ch === delim){
        row.push(cur); cur="";
      } else if(ch === '\n'){
        row.push(cur); rows.push(row);
        row=[]; cur="";
      } else if(ch === '\r'){
        // ignore
      } else cur += ch;
    }
  }
  row.push(cur); rows.push(row);
  // trim trailing empty rows
  while(rows.length && rows[rows.length-1].every(c=>String(c??"").trim()==="")) rows.pop();
  return rows;
}
function isRowEmpty(r){ return !r || r.every(c=>String(c??"").trim()===""); }
function splitBlocks(rows){
  const blocks = [];
  let cur = [];
  for(const r of rows){
    if(isRowEmpty(r)){
      if(cur.length){ blocks.push(cur); cur=[]; }
    } else cur.push(r);
  }
  if(cur.length) blocks.push(cur);
  return blocks;
}

/* ========== AMP reshape ========== */
function detectTraceHeader(header){
  // Returns indices of trace columns and their names.
  const cols = [];
  for(let i=0;i<header.length;i++){
    const h = String(header[i]??"").trim();
    if(/^(trace\s*\d+|trace\d+)$/i.test(h) || /^Trace\s*\d+/i.test(h)){
      cols.push({i, name:h});
    }
  }
  // If none, try all columns after first as traces if "Trace" appears anywhere
  if(!cols.length){
    const anyTrace = header.some(h=>/trace/i.test(String(h||"")));
    if(anyTrace && header.length>=3){
      for(let i=1;i<header.length;i++){
        cols.push({i, name:String(header[i]??`Trace ${i}`).trim() || `Trace ${i}`});
      }
    }
  }
  return cols;
}

function parseMetricBlock(block){
  // wide: first row header: ["", "Trace 1", ...]
  const header = block[0].map(x => String(x??"").trim());
  const traces = header.slice(1).map((h,i)=>h||`Trace ${i+1}`);
  const n = traces.length;
  if(n<1) return null;

  // map varName -> array (len n)
  const map = new Map();
  for(let r=1;r<block.length;r++){
    const varName = String(block[r][0]??"").trim();
    if(!varName) continue;
    const vals = [];
    for(let c=1;c<1+n;c++){
      vals.push(block[r][c] ?? "");
    }
    map.set(varName, vals);
  }
  function getVar(keys){
    for(const k of keys){
      for(const [name, vals] of map.entries()){
        if(name.toLowerCase() === k.toLowerCase()) return {name, vals};
      }
    }
    for(const k of keys){
      for(const [name, vals] of map.entries()){
        if(name.toLowerCase().includes(k.toLowerCase())) return {name, vals};
      }
    }
    return null;
  }

  const flyerRow = getVar(["Flyer"]);
  const peakRow  = getVar(["Peak Force"]);
  const workRow  = getVar(["Work Done"]);
  const startRow = getVar(["Starting Pos","Starting Position"]);
  const termRow  = getVar(["Terminal Force"]);

  if(!peakRow && !workRow && !startRow && !termRow) return null;

  const rounds = [];
  for(let i=0;i<n;i++){
    const traceName = traces[i] || `Trace ${i+1}`;
    const flyer = flyerRow ? String(flyerRow.vals[i]??"").trim().toLowerCase()==="true" : false;
    rounds.push({
      traceIndex: i+1,
      trace: traceName,
      flyerRaw: flyer,
      flyer: flyer,
      peakForce: peakRow ? toNum(peakRow.vals[i]) : null,
      workDone: workRow ? toNum(workRow.vals[i]) : null,
      startingPos: startRow ? toNum(startRow.vals[i]) : null,
      terminalForce: termRow ? toNum(termRow.vals[i]) : null,
      curve: null, // {x:[], y:[]}
      // curve features
      earlySpike: null,
      roughness: null,
      endFlat: null,
      endDrop: null,
      midSlope: null,
      // scoring
      z: {},
      score: 0,
      bucket: "normal",
      driver: "—",
      diags: [],
      cause: "—",
      conf: 0
    });
  }
  return {rounds, map, n};
}

function parseCurveBlock(block){
  // Expect header row with first col like Position/Depth and trace columns after
  const header = block[0].map(x => String(x??"").trim());
  const traceCols = detectTraceHeader(header);
  if(!traceCols.length) return null;

  // find x column: prefer first col if it contains 'pos'/'depth' or has numeric rows
  let xIdx = 0;
  for(let i=0;i<header.length;i++){
    const h = header[i].toLowerCase();
    if(h.includes('pos') || h.includes('depth') || h.includes('mm') || h.includes('in')) { xIdx=i; break; }
  }

  const xs = [];
  const ysByTrace = traceCols.map(()=>[]);
  for(let r=1;r<block.length;r++){
    const x = toNum(block[r][xIdx]);
    if(!Number.isFinite(x)) continue;
    xs.push(x);
    traceCols.forEach((tc,ti)=>{
      ysByTrace[ti].push(toNum(block[r][tc.i]));
    });
  }
  if(xs.length < 10) return null;

  return {
    traces: traceCols.map(tc=>tc.name),
    x: xs,
    ysByTrace
  };
}

function computeCurveFeatures(round){
  const c = round.curve;
  if(!c || !c.y || c.y.length<10) return;
  const y = c.y.filter(v=>Number.isFinite(v));
  if(y.length<10) return;

  const n = y.length;
  const yMin = Math.min(...y), yMax = Math.max(...y);
  const range = (yMax - yMin) || 1e-9;

  const kEarly = Math.max(5, Math.floor(n*0.12));
  const kEnd   = Math.max(5, Math.floor(n*0.12));
  const early = y.slice(0, kEarly);
  const end   = y.slice(n-kEnd);

  const earlyMax = Math.max(...early);
  const overallMax = yMax;
  round.earlySpike = (overallMax>0) ? (earlyMax / overallMax) : null; // ratio

  // roughness: mean abs 2nd diff normalized by range
  let s2 = 0, cnt = 0;
  for(let i=1;i<n-1;i++){
    const d2 = (y[i+1]-2*y[i]+y[i-1]);
    s2 += Math.abs(d2);
    cnt++;
  }
  round.roughness = cnt ? (s2/cnt)/range : null;

  // endFlat: end segment amplitude small
  const endMin = Math.min(...end), endMax = Math.max(...end);
  const endAmp = (endMax-endMin)/range;
  round.endFlat = endAmp; // smaller is flatter (we will invert for z)

  // endDrop: slope of last segment (linear fit) normalized by range
  // using index as x if real x missing
  let sumX=0,sumY=0,sumXY=0,sumXX=0;
  for(let i=0;i<end.length;i++){
    const xx=i, yy=end[i];
    sumX += xx; sumY += yy; sumXY += xx*yy; sumXX += xx*xx;
  }
  const denom = (kEnd*sumXX - sumX*sumX) || 1e-9;
  const slope = (kEnd*sumXY - sumX*sumY)/denom; // units per index
  round.endDrop = slope / range; // negative means dropping

  // midSlope: slope from 10% to 60%
  const a0 = Math.floor(n*0.10);
  const a1 = Math.floor(n*0.60);
  const mid = y.slice(a0, Math.max(a0+5,a1));
  let sx=0, sy=0, sxy=0, sxx=0;
  for(let i=0;i<mid.length;i++){
    const xx=i, yy=mid[i];
    sx+=xx; sy+=yy; sxy+=xx*yy; sxx+=xx*xx;
  }
  const den = (mid.length*sxx - sx*sx) || 1e-9;
  const ms = (mid.length*sxy - sx*sy)/den;
  round.midSlope = ms / range; // higher => steeper
}

function buildSession(rows, filename){
  const blocks = splitBlocks(rows);
  let metric = null;
  let curve = null;

  // choose best metric block: contains Peak Force row
  for(const b of blocks){
    const m = parseMetricBlock(b);
    if(m){ metric = m; break; }
  }
  if(!metric) throw new Error("Couldn't find AMP metric rows (Peak Force/Work Done/etc).");

  // choose best curve block: numeric x + trace columns
  for(const b of blocks){
    const c = parseCurveBlock(b);
    if(c){
      // sanity: number of traces should match metric count OR at least >1
      curve = c; break;
    }
  }

  // attach curves if sizes match (by index)
  if(curve){
    // If curve traces count doesn't match, we still map by order up to min
    const mN = metric.rounds.length;
    const cN = curve.ysByTrace.length;
    const n = Math.min(mN, cN);
    for(let i=0;i<n;i++){
      metric.rounds[i].curve = {x: curve.x, y: curve.ysByTrace[i]};
      computeCurveFeatures(metric.rounds[i]);
    }
  }

  // compute stats + scores
  const rounds = metric.rounds;

  // scalar metrics
  const scalarMetrics = [
    {key:"peakForce", label:"Peak Force", w:1.00},
    {key:"workDone", label:"Work Done", w:0.85},
    {key:"startingPos", label:"Starting Pos", w:0.70},
    {key:"terminalForce", label:"Terminal Force", w:0.70}
  ];

  // curve metrics (if present)
  const curveMetrics = [
    // earlySpike higher means more spike
    {key:"earlySpike", label:"Early Spike", w:0.65, present: r=>Number.isFinite(r.earlySpike)},
    // roughness higher means more jagged
    {key:"roughness", label:"Jagged", w:0.75, present: r=>Number.isFinite(r.roughness)},
    // endFlat smaller means flatter: use inv
    {key:"endFlat", label:"End Flat", w:0.55, present: r=>Number.isFinite(r.endFlat), invert:true},
    // endDrop negative means drop: use negative to highlight drops
    {key:"endDrop", label:"End Drop", w:0.55, present: r=>Number.isFinite(r.endDrop), signed:true, negativeIsBad:true},
    {key:"midSlope", label:"Mid Slope", w:0.35, present: r=>Number.isFinite(r.midSlope)}
  ];

  // build stats
  const stats = {};
  function makeStats(key){
    const arr = rounds.map(r=>r[key]).filter(v=>Number.isFinite(v));
    const med = median(arr);
    let theMad = (med==null) ? null : mad(arr, med);
    let sd=null, mu=null;
    if(!theMad || theMad===0){
      sd = stdev(arr);
      mu = mean(arr);
    }
    return {med, mad: theMad, sd, mu};
  }

  for(const m of scalarMetrics){
    stats[m.key] = {...makeStats(m.key), label:m.label};
  }
  const hasCurves = rounds.some(r=>r.curve && r.curve.y && r.curve.y.length>=10);
  if(hasCurves){
    for(const m of curveMetrics){
      // include only if at least some values exist
      const exists = rounds.some(r=>m.present(r));
      if(!exists) continue;
      stats[m.key] = {...makeStats(m.key), label:m.label, invert: !!m.invert, signed: !!m.signed, negativeIsBad: !!m.negativeIsBad};
    }
  }

  // baseline stats (optional)
  const base = getBaselineForScoring();

  // score each round
  for(const r of rounds){
    let scoreSum=0, wSum=0;
    let driverAbs=-1, driver="—";

    // scalar z
    for(const m of scalarMetrics){
      const st = stats[m.key];
      const z = robustZ(r[m.key], st);
      r.z[m.key]=z;
      const az = Math.abs(z);
      scoreSum += m.w*az; wSum += m.w;
      if(az>driverAbs){ driverAbs=az; driver=`${m.label} (${az.toFixed(2)}σ)`; }
    }

    // curve z (with special handling)
    if(hasCurves){
      for(const m of curveMetrics){
        const st = stats[m.key];
        if(!st) continue;
        if(!m.present(r)) { r.z[m.key]=0; continue; }

        let val = r[m.key];
        // invert endFlat so "flatter" = bigger badness
        if(m.invert) val = -val;
        // for signed negative-is-bad, emphasize negative direction
        let z = robustZ(val, {...st, med: st.med!=null ? (m.invert? -st.med : st.med) : st.med});
        if(m.negativeIsBad){
          // treat positive slopes as OK, negative as bad; clamp to <=0 then take abs
          z = Math.min(0, z);
        }
        r.z[m.key]=z;
        const az = Math.abs(z);
        scoreSum += m.w*az; wSum += m.w;
        if(az>driverAbs){
          driverAbs=az;
          driver=`${m.label} (${az.toFixed(2)}σ)`;
        }
      }
    }

    // baseline comparison bump (session-wide drift)
    let baseBump = 0;
    if(base){
      // Compare key medians: peakForce, workDone, midSlope (if available)
      // If current session median is far from baseline, add small bump so it appears in summary/driver.
      const curPF = stats.peakForce.med, basePF = base.metrics?.peakForce?.med;
      if(Number.isFinite(curPF) && Number.isFinite(basePF) && basePF!==0){
        const rel = Math.abs(curPF-basePF)/Math.abs(basePF);
        if(rel>0.12) baseBump += Math.min(0.6, rel*2.0); // cap
      }
      const curWD = stats.workDone.med, baseWD = base.metrics?.workDone?.med;
      if(Number.isFinite(curWD) && Number.isFinite(baseWD) && baseWD!==0){
        const rel = Math.abs(curWD-baseWD)/Math.abs(baseWD);
        if(rel>0.12) baseBump += Math.min(0.5, rel*1.6);
      }
      const curMS = stats.midSlope?.med, baseMS = base.curves?.midSlope?.med;
      if(Number.isFinite(curMS) && Number.isFinite(baseMS) && baseMS!==0){
        const rel = Math.abs(curMS-baseMS)/Math.abs(baseMS);
        if(rel>0.15) baseBump += Math.min(0.4, rel*1.2);
      }
      if(baseBump>0 && driverAbs<1.2){
        driver = `Baseline drift (+${baseBump.toFixed(2)})`;
      }
    }

    let score = wSum>0 ? (scoreSum/wSum) : 0;
    score += baseBump;

    // flyer determination: existing Flyer row OR any metric abs(z) >= 3.5
    let computedFlyer = false;
    for(const k in r.z){
      if(Math.abs(r.z[k]) >= 3.5) { computedFlyer = true; break; }
    }
    r.flyer = r.flyerRaw || computedFlyer;
    if(r.flyer) score = Math.max(score, 3.0) + 0.55;

    r.score = score;
    r.driver = driver;
    r.bucket = clsFromScore(score);

    // diagnostics + cause labels
    assignDiagnosticsAndCause(r, hasCurves);
  }

  // session summary
  const anomCnt = rounds.filter(r=>r.score >= state.threshold).length;
  const peakArr = rounds.map(r=>r.peakForce).filter(v=>Number.isFinite(v));
  const peakMed = median(peakArr);
  const curveYes = hasCurves ? "yes" : "no";

  return {
    name: filename,
    rounds,
    stats,
    hasCurves,
    summary: { 
      n: rounds.length, 
      anomalies: anomCnt, 
      flyers: rounds.filter(r=>r.flyer).length,
      peakMed, 
      peakES: (peakArr.length ? (Math.max(...peakArr)-Math.min(...peakArr)) : null),
      workMed: median(rounds.map(r=>r.workDone).filter(v=>Number.isFinite(v))),
      roughMed: median(rounds.map(r=>r.roughness).filter(v=>Number.isFinite(v))),
      curveYes 
    }
  };
}

function assignDiagnosticsAndCause(r, hasCurves){
  const diags = [];

  // scalar triggers
  const azPeak = Math.abs(r.z.peakForce||0);
  const azWork = Math.abs(r.z.workDone||0);
  const azTerm = Math.abs(r.z.terminalForce||0);

  // curve triggers (z values computed)
  const azEarly = Math.abs(r.z.earlySpike||0);
  const azRough = Math.abs(r.z.roughness||0);
  const azFlat  = Math.abs(r.z.endFlat||0);
  const azDrop  = Math.abs(r.z.endDrop||0);

  const t = state.threshold;


  // severity tiers for curve diagnostics (for UI glyphs)
  if(hasCurves){
    r.diagStrength = {
      earlySpike: strengthTier(azEarly),
      jagged: strengthTier(azRough),
      endFlat: strengthTier(azFlat),
      endDrop: strengthTier(azDrop)
    };
  } else {
    r.diagStrength = null;
  }

  // add diag tags based on notable drivers (use fixed smaller thresholds for flags)
  if(azPeak>=2.2 || azWork>=2.2 || azTerm>=2.2) diags.push("Force outlier");
  if(hasCurves){
    if(azEarly>=2.0) diags.push("Early spike");
    if(azRough>=2.0) diags.push("Jagged");
    if(azFlat>=2.0) diags.push("End flat");
    if(azDrop>=2.0) diags.push("End drop");
  }
  if(r.flyer) diags.unshift("Flyer");

  r.diags = diags.length ? diags : ["—"];

  // probable cause mapping (pick top feature)
  const candidates = [];
  // (scoreContribution, label, confidenceHint)
  if(hasCurves && azEarly>=1.6) candidates.push([azEarly, "Case mouth / chamfer / donut", 0.70]);
  if(hasCurves && azRough>=1.6) candidates.push([azRough, "Carbon / neck-wall inconsistency / damage", 0.68]);
  if(azPeak>=1.8 || azWork>=1.8) candidates.push([Math.max(azPeak,azWork), "Neck tension / sizing / anneal variance", 0.64]);
  if(hasCurves && (azFlat>=1.8 || azDrop>=1.8)) candidates.push([Math.max(azFlat, azDrop), "Bearing surface / seating setup inconsistency", 0.55]);

  // baseline drift could be session-wide; for per-round we keep cause from z.
  // Build explainability: top contributing standardized signals (z-scores)
  const contrib = [];
  // force/scalars
  contrib.push(["Peak Force", r.z.peakForce||0]);
  contrib.push(["Work Done", r.z.workDone||0]);
  contrib.push(["Terminal Force", r.z.terminalForce||0]);
  if(hasCurves){
    contrib.push(["Early spike", r.z.earlySpike||0]);
    contrib.push(["Jaggedness", r.z.roughness||0]);
    contrib.push(["End flat", r.z.endFlat||0]);
    contrib.push(["End drop", r.z.endDrop||0]);
  } else {
    r.noCurveData = true;
  }
  const contribTop = contrib
    .map(([lab,z])=>({lab, z:Number(z)||0, az:Math.abs(Number(z)||0)}))
    .filter(o=>o.az>=1.0)
    .sort((a,b)=>b.az-a.az)
    .slice(0,3);

  candidates.sort((a,b)=>b[0]-a[0]);

  if(!candidates.length){
    r.cause = "—";
    r.conf = 0;
    return;
  }

  const [topZ, cause, baseConf] = candidates[0];
  // confidence: scale with severity, capped
  let conf = Math.min(0.95, baseConf + Math.max(0, (topZ-2.0))*0.08);
  if(r.flyer) conf = Math.min(0.98, conf + 0.08);
  r.cause = cause;
  r.conf = conf;

  // Human-readable one-liner for tooltips
  if(typeof contribTop !== "undefined" && contribTop && contribTop.length){
    r.causeExplain = contribTop.map(o=>`${o.lab} ${o.z>=0?'+':''}${o.z.toFixed(2)}σ`).join(' • ');
  } else if(r.noCurveData){
    r.causeExplain = "No curve columns in this export (force-only signals).";
  } else {
    r.causeExplain = "—";
  }
}

/* ========== baseline storage ========== */
const BASE_KEY = "amp_diag_baseline_v1";
function loadBaseline(){
  try{
    const s = localStorage.getItem(BASE_KEY);
    if(!s) return null;
    return JSON.parse(s);
  }catch(e){ return null; }
}
function saveBaseline(obj){
  try{ localStorage.setItem(BASE_KEY, JSON.stringify(obj)); }catch(e){}
}
function clearBaseline(){
  try{ localStorage.removeItem(BASE_KEY); }catch(e){}
}
function getBaselineForScoring(){
  if(state.baselineMode==="none") return null;
  if(state.baselineMode==="active"){
    const sess = state.sessions[state.activeIndex];
    if(!sess) return null;
    return sessionToBaseline(sess);
  }
  if(state.baselineMode==="custom"){
    return state.baseline || null;
  }
  return null;
}
function sessionToBaseline(sess){
  const b = {metrics:{}, curves:{}};
  // store medians
  for(const k of ["peakForce","workDone","startingPos","terminalForce"]){
    const st = sess.stats?.[k];
    if(st && st.med!=null) b.metrics[k]={med:st.med};
  }
  for(const k of ["earlySpike","roughness","endFlat","endDrop","midSlope"]){
    const st = sess.stats?.[k];
    if(st && st.med!=null) b.curves[k]={med:st.med};
  }
  return b;
}

/* ========== rendering ========== */

function recomputeSessionPostFlags(sess){
  // tags: top5/bottom5 by Peak Force; ES-based exclusion of extremes
  if(!sess || !sess.rounds) return sess;
  const rounds = sess.rounds;
  // clear prior tags/exclusions that are derived
  for(const r of rounds){
    r.tag = "";
    r.excluded = false;
    r.flags = (r.flags && Array.isArray(r.flags)) ? r.flags.filter(f=>!f.startsWith("ES ") && f!=="Top5" && f!=="Bottom5") : [];
    // keep diag list but remove ES breach / tags (we'll re-add)
    if(r.diags && Array.isArray(r.diags)){
      r.diags = r.diags.filter(d=>d!=="ES breach" && d!=="Top5" && d!=="Bottom5");
    }
  }

  const peakPairs = rounds
    .map((r,i)=>({i, v:r.peakForce}))
    .filter(o=>Number.isFinite(o.v))
    .sort((a,b)=>b.v-a.v);

  // Tag top/bottom 5 (or fewer if small session)
  const k = Math.min(5, peakPairs.length);
  for(let j=0;j<k;j++){
    const topIdx = peakPairs[j].i;
    const botIdx = peakPairs[peakPairs.length-1-j].i;
    const rt = rounds[topIdx];
    const rb = rounds[botIdx];
    if(rt){
      rt.tag = rt.tag ? (rt.tag+";Top5") : "Top5";
      rt.flags = rt.flags || [];
      rt.flags.push("Top5");
    }
    if(rb){
      rb.tag = rb.tag ? (rb.tag+";Bottom5") : "Bottom5";
      rb.flags = rb.flags || [];
      rb.flags.push("Bottom5");
    }
  }

  // Session ES (Peak Force)
  const peaks = peakPairs.map(o=>o.v);
  const peakES = peaks.length ? (peaks[0]-peaks[peaks.length-1]) : null;
  sess.summary.peakES = peakES;

  // Auto-exclude extremes when ES exceeds limit
  if(state.esAutoExclude && Number.isFinite(peakES) && peakES > state.esLimit && peakPairs.length){
    const maxIdx = peakPairs[0].i;
    const minIdx = peakPairs[peakPairs.length-1].i;
    for(const idx of [maxIdx, minIdx]){
      const r = rounds[idx];
      if(!r) continue;
      r.excluded = true;
      r.flags = r.flags || [];
      r.flags.push(`ES > ${state.esLimit}lb`);
      if(r.diags && Array.isArray(r.diags)){
        if(!r.diags.includes("ES breach")) r.diags.unshift("ES breach");
      }else{
        r.diags = ["ES breach"];
      }
      // Treat as high anomaly driver for review without forcing Flyer
      r.score = Math.max(r.score, state.threshold + 0.15);
      r.bucket = clsFromScore(r.score);
    }
  }
  return sess;
}

function renderSessionOptions(){
  els.sessionSel.innerHTML = "";
  state.sessions.forEach((s, idx)=>{
    const opt = document.createElement('option');
    opt.value = String(idx);
    opt.textContent = `${s.name} (${s.summary.n} rounds)`;
    els.sessionSel.appendChild(opt);
  });
  els.sessionSel.value = String(state.activeIndex || 0);
}
function getActiveSession(){ return state.sessions[state.activeIndex] || null; }
function renderSessionsView(){
  // ensure summaries up to date
  state.sessions.forEach(s=>recomputeSessionPostFlags(s));
  if(!state.sessions.length){
    els.sessionsWrap.style.display='none';
    return;
  }
  const rows = state.sessions.map((s,idx)=>({
    idx,
    name:s.name,
    n:s.summary.n,
    flyers:s.rounds.filter(r=>r.flyer).length,
    anomalies:s.rounds.filter(r=>r.score>=state.threshold).length,
    peakMed:s.summary.peakMed,
    peakES:s.summary.peakES,
    workMed:s.summary.workMed,
    roughMed:s.summary.roughMed
  }));

  // draw chart (median peak + ES)
  drawSessionChart(rows);

  els.sessionsTbody.innerHTML = rows.map((r,i)=>{
    return `<tr data-idx="${r.idx}">
      <td title="${escapeHtml(r.name)}">${escapeHtml(r.name)}</td>
      <td class="mono">${r.n}</td>
      <td class="mono">${r.flyers}</td>
      <td class="mono">${r.anomalies}</td>
      <td class="mono">${r.peakMed==null?'—':fmt(r.peakMed,2)}</td>
      <td class="mono">${r.peakES==null?'—':fmt(r.peakES,1)}</td>
      <td class="mono">${r.workMed==null?'—':fmt(r.workMed,2)}</td>
      <td class="mono">${r.roughMed==null?'—':fmt(r.roughMed,4)}</td>
    </tr>`;
  }).join("");

  // click handler
  Array.from(els.sessionsTbody.querySelectorAll('tr')).forEach(tr=>{
    tr.addEventListener('click', ()=>{
      const idx = Number(tr.getAttribute('data-idx'));
      if(Number.isFinite(idx)){
        state.activeIndex = idx;
        renderSessionOptions();
        // switch back to rounds view
        state.view='rounds';
        els.tabRounds.classList.add('active'); els.tabSessions.classList.remove('active'); if(els.tabCorr) els.tabCorr.classList.remove('active');
        els.sessionsWrap.style.display='none';
        els.tableWrap.style.display='block';
        render();
      }
    });
  });
}

function drawSessionChart(rows){
  const c = els.sessChart;
  if(!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);

  // compute scales
  const medVals = rows.map(r=>r.peakMed).filter(v=>Number.isFinite(v));
  const esVals = rows.map(r=>r.peakES).filter(v=>Number.isFinite(v));
  if(!medVals.length && !esVals.length){
    ctx.fillStyle = 'rgba(255,255,255,.55)';
    ctx.font = '14px ui-sans-serif';
    ctx.fillText('No chartable values (need Peak Force values).', 12, 22);
    return;
  }
  const xPad=28, yPad=18, plotW=W-xPad*2, plotH=H-yPad*2;
  const minMed=Math.min(...medVals), maxMed=Math.max(...medVals);
  const minES=esVals.length?Math.min(...esVals):0, maxES=esVals.length?Math.max(...esVals):1;

  function x(i){ return xPad + (rows.length<=1? 0 : (i/(rows.length-1))*plotW); }
  function yMed(v){
    if(!Number.isFinite(v)) return null;
    const t = (v-minMed)/((maxMed-minMed)||1);
    return yPad + (1-t)*plotH;
  }
  function yES(v){
    if(!Number.isFinite(v)) return null;
    const t = (v-minES)/((maxES-minES)||1);
    return yPad + (1-t)*plotH;
  }

  // axes
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(xPad, yPad);
  ctx.lineTo(xPad, yPad+plotH);
  ctx.lineTo(xPad+plotW, yPad+plotH);
  ctx.stroke();

  // line: med
  ctx.strokeStyle = 'rgba(124,220,255,.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  let started=false;
  rows.forEach((r,i)=>{
    const yy=yMed(r.peakMed);
    if(yy==null) return;
    const xx=x(i);
    if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // points: med
  ctx.fillStyle = 'rgba(124,220,255,.95)';
  rows.forEach((r,i)=>{
    const yy=yMed(r.peakMed); if(yy==null) return;
    const xx=x(i);
    ctx.beginPath(); ctx.arc(xx,yy,3,0,Math.PI*2); ctx.fill();
  });

  // line: ES
  ctx.strokeStyle = 'rgba(255,184,124,.75)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  started=false;
  rows.forEach((r,i)=>{
    const yy=yES(r.peakES);
    if(yy==null) return;
    const xx=x(i);
    if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // points: ES
  ctx.fillStyle = 'rgba(255,184,124,.9)';
  rows.forEach((r,i)=>{
    const yy=yES(r.peakES); if(yy==null) return;
    const xx=x(i);
    ctx.beginPath(); ctx.arc(xx,yy,3,0,Math.PI*2); ctx.fill();
  });

  // labels
  ctx.fillStyle = 'rgba(255,255,255,.55)';
  ctx.font = '12px ui-sans-serif';
  ctx.fillText('Peak Med', xPad+6, yPad+12);
  ctx.fillText('Peak ES', xPad+80, yPad+12);
}


function setupHeaderSort(){
  const headerMap = new Map([
    ["Trace","traceIndex"],
    ["Flyer","flyer"],
    ["Excluded","excluded"],
    ["Tag","tag"],
    ["Cause","cause"],
    ["Conf","conf"],
    ["Score","score"],
    ["Peak Force","peakForce"],
    ["Work Done","workDone"],
    ["Starting Pos","startingPos"],
    ["Terminal Force","terminalForce"],
    ["Early Spike","earlySpike"],
    ["Jagged","roughness"],
    ["End Flat","endFlat"],
    ["End Drop","endDrop"]
  ]);
  const ths = document.querySelectorAll("#tableWrap thead th");
  ths.forEach(th=>{
    const label = (th.textContent||"").trim();
    const field = headerMap.get(label);
    if(!field) return;
    th.style.cursor = "pointer";
    th.title = "Click to sort";
    th.addEventListener("click", ()=>{
      // toggle
      if(state.sortField === field){
        state.sortDir = (state.sortDir === "asc") ? "desc" : "asc";
      } else {
        state.sortField = field;
        // default directions: numeric desc, booleans true-first, strings asc
        const numericFields = new Set(["traceIndex","score","peakForce","workDone","startingPos","terminalForce","earlySpike","roughness","endFlat","endDrop","conf"]);
        if(numericFields.has(field)) state.sortDir = (field==="traceIndex") ? "asc" : "desc";
        else state.sortDir = "asc";
      }
      // mark sort mode
      state.sort = 'custom';
      if(els.sortSel) els.sortSel.value = 'custom';
      // visual hint
      ths.forEach(x=>x.classList.remove("sortedAsc","sortedDesc"));
      th.classList.add(state.sortDir==="asc" ? "sortedAsc" : "sortedDesc");
      render();
    });
  });
}

function exportSessionsCSV(){
  const csvCellLocal = (v)=>{
    let s = (v==null) ? "" : String(v);
    if(/[",\n]/.test(s)) s = `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const header = ["Session","Rounds","Flyers","Anomalies","Peak Med","Peak ES","Work Med","Rough Med"];
  const lines = exportPreambleLines("shown_rounds").concat([header.join(",")]);
  for(const s of state.sessions){
    const row = [
      s.name,
      s.summary.n,
      s.rounds.filter(r=>r.flyer).length,
      s.rounds.filter(r=>r.score>=state.threshold).length,
      s.summary.peakMed==null? "": s.summary.peakMed,
      s.summary.peakES==null? "": s.summary.peakES,
      s.summary.workMed==null? "": s.summary.workMed,
      s.summary.roughMed==null? "": s.summary.roughMed
    ].map(csvCellLocal).join(",");
    lines.push(row);
  }
  const blob = new Blob([lines.join("\n")], {type:"text/csv"});
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url;
  a.download = "amp_sessions_summary.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}


function matchesQuery(r, q){
  if(!q) return true;
  q = q.toLowerCase();
  return (
    String(r.trace).toLowerCase().includes(q) ||
    String(r.driver).toLowerCase().includes(q) ||
    String(r.cause).toLowerCase().includes(q) ||
    String(r.diags.join(" ")).toLowerCase().includes(q)
  );
}

function renderTraceChart(){
  const c = els.traceChart;
  if(!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);
  state.tcPoints = [];

  const sess = getActiveSession();
  if(!sess || !sess.rounds || !sess.rounds.length){
    ctx.fillStyle = 'rgba(255,255,255,.55)';
    ctx.font = '14px ui-sans-serif';
    ctx.fillText('Load a session to see the trace chart.', 12, 22);
    return;
  }

  let rounds = (state.traceChart && state.traceChart.useFiltered) ? (state.shownRows||[]) : sess.rounds.slice();
  if(!(state.traceChart && state.traceChart.showExcluded)){
    rounds = rounds.filter(r=>!r.excluded);
  }
  drawTraceChart(rounds, {overlayWork: !!(state.traceChart && state.traceChart.overlayWork)});
}

function drawTraceChart(rounds, opts){
  const c = els.traceChart;
  if(!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);

  const peak = rounds.map(r=>r.peakForce).filter(v=>Number.isFinite(v));
  if(!peak.length){
    ctx.fillStyle = 'rgba(255,255,255,.55)';
    ctx.font = '14px ui-sans-serif';
    ctx.fillText('No Peak Force values to chart.', 12, 22);
    return;
  }
  const work = rounds.map(r=>r.workDone).filter(v=>Number.isFinite(v));
  const overlayWork = !!opts.overlayWork && work.length>1;

  const xPad=34, yPad=18, plotW=W-xPad*2, plotH=H-yPad*2;

  const minX = Math.min(...rounds.map(r=>r.traceIndex||0)), maxX = Math.max(...rounds.map(r=>r.traceIndex||0));
  const minP = Math.min(...peak), maxP = Math.max(...peak);
  const pPad = (maxP-minP)*0.08 || 1;
  const yMinP = minP - pPad, yMaxP = maxP + pPad;

  let yMinW=0, yMaxW=1;
  if(overlayWork){
    const minW=Math.min(...work), maxW=Math.max(...work);
    const wPad=(maxW-minW)*0.08 || 0.01;
    yMinW=minW-wPad; yMaxW=maxW+wPad;
  }

  const x = (xi)=>{
    const t = (xi-minX)/((maxX-minX)||1);
    return xPad + t*plotW;
  };
  const yP = (v)=>{
    const t = (v-yMinP)/((yMaxP-yMinP)||1);
    return yPad + (1-t)*plotH;
  };
  const yW = (v)=>{
    const t = (v-yMinW)/((yMaxW-yMinW)||1);
    return yPad + (1-t)*plotH;
  };

  // axes
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(xPad, yPad);
  ctx.lineTo(xPad, yPad+plotH);
  ctx.lineTo(xPad+plotW, yPad+plotH);
  ctx.stroke();

  // y labels (minimal)
  ctx.fillStyle = 'rgba(255,255,255,.45)';
  ctx.font = '12px ui-sans-serif';
  ctx.fillText('Peak', 8, 22);
  if(overlayWork) ctx.fillText('Work', 8, 38);


  // ES bounds (Peak Force) + ES-limit band
  const peakValsAll = rounds.map(r=>r.peakForce).filter(v=>Number.isFinite(v));
  const minPeakAll = peakValsAll.length ? Math.min(...peakValsAll) : null;
  const maxPeakAll = peakValsAll.length ? Math.max(...peakValsAll) : null;
  const esAll = (minPeakAll!=null && maxPeakAll!=null) ? (maxPeakAll-minPeakAll) : null;
  if(esAll!=null){
    const yMin = yP(minPeakAll), yMax = yP(maxPeakAll);
    ctx.save();
    ctx.setLineDash([6,4]);
    ctx.strokeStyle = 'rgba(255,255,255,.14)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(xPad, yMin); ctx.lineTo(xPad+plotW, yMin); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xPad, yMax); ctx.lineTo(xPad+plotW, yMax); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255,255,255,.45)';
    ctx.font = '12px ui-sans-serif';
    ctx.fillText('Peak ES: '+fmt(esAll,1)+' lb', xPad+8, yPad+12);
    ctx.restore();

    // ES limit band around median (if set)
    if(Number.isFinite(state.esLimit) && state.esLimit>0){
      const med = median(peakValsAll);
      const half = state.esLimit/2;
      const yLo = yP(med-half), yHi = yP(med+half);
      ctx.save();
      ctx.setLineDash([3,5]);
      ctx.strokeStyle = 'rgba(124,220,255,.18)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(xPad, yLo); ctx.lineTo(xPad+plotW, yLo); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(xPad, yHi); ctx.lineTo(xPad+plotW, yHi); ctx.stroke();
      ctx.fillStyle = 'rgba(124,220,255,.45)';
      ctx.font = '12px ui-sans-serif';
      ctx.fillText('ES limit band (±'+fmt(half,1)+' lb)', xPad+8, yPad+26);
      ctx.restore();
    }
  }

  // Peak line
  ctx.strokeStyle = 'rgba(124,220,255,.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  let started=false;
  rounds.slice().sort((a,b)=>(a.traceIndex||0)-(b.traceIndex||0)).forEach((r)=>{
    if(!Number.isFinite(r.peakForce)) return;
    const xx=x(r.traceIndex||0), yy=yP(r.peakForce);
    if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // Work line (optional)
  if(overlayWork){
    ctx.strokeStyle = 'rgba(255,180,92,.78)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    started=false;
    rounds.slice().sort((a,b)=>(a.traceIndex||0)-(b.traceIndex||0)).forEach((r)=>{
      if(!Number.isFinite(r.workDone)) return;
      const xx=x(r.traceIndex||0), yy=yW(r.workDone);
      if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);
    });
    ctx.stroke();
  }

  // Points / highlights
  rounds.forEach((r)=>{
    const xi=r.traceIndex||0;
    if(!Number.isFinite(r.peakForce)) return;
    const xx=x(xi), yy=yP(r.peakForce);

    // base style
    let fill='rgba(124,220,255,.92)';
    let stroke=null, lw=2, rad=4;

    if(r.excluded){
      fill='rgba(200,200,210,.55)';
      rad=3.5;
    }
    if(r.tag==="Top5"){
      fill='rgba(96,205,255,.95)';
      rad=5;
    }else if(r.tag==="Bottom5"){
      fill='rgba(120,255,170,.92)';
      rad=5;
    }
    if(r.flyer){
      stroke='rgba(255,90,90,.95)';
      lw=2.5;
      rad=5.5;
    }

    ctx.beginPath();
    ctx.arc(xx,yy,rad,0,Math.PI*2);
    ctx.fillStyle=fill;
    ctx.fill();
    if(stroke){
      ctx.strokeStyle=stroke;
      ctx.lineWidth=lw;
      ctx.stroke();
    }
  });

  // Legend (tiny)
  ctx.fillStyle='rgba(255,255,255,.52)';
  ctx.font='12px ui-sans-serif';
  ctx.fillText('Peak Force', xPad+8, yPad+14);
  if(overlayWork) ctx.fillText('Work Done', xPad+92, yPad+14);
}



function showFloatTip(html, x, y){
  const tip = document.getElementById('floatTip');
  if(!tip) return;
  tip.innerHTML = html;
  tip.style.display = 'block';
  const pad = 12;
  const vw = window.innerWidth, vh = window.innerHeight;
  // measure
  tip.style.left = '0px'; tip.style.top = '0px';
  const rect = tip.getBoundingClientRect();
  let left = x + pad;
  let top = y + pad;
  if(left + rect.width + pad > vw) left = x - rect.width - pad;
  if(top + rect.height + pad > vh) top = y - rect.height - pad;
  left = Math.max(pad, Math.min(vw - rect.width - pad, left));
  top = Math.max(pad, Math.min(vh - rect.height - pad, top));
  tip.style.left = left + 'px';
  tip.style.top = top + 'px';
}
function hideFloatTip(){
  const tip = document.getElementById('floatTip');
  if(tip) tip.style.display = 'none';
}
function initTraceChartHover(){
  const c = els.traceChart;
  if(!c) return;
  c.addEventListener('mouseleave', ()=>{ hideFloatTip(); });
  c.addEventListener('mousemove', (ev)=>{
    const rect = c.getBoundingClientRect();
    const mx = (ev.clientX - rect.left) * (c.width / rect.width);
    const my = (ev.clientY - rect.top) * (c.height / rect.height);
    // find nearest point
    let best = null, bestD = 1e9;
    for(const p of (state.tcPoints||[])){
      const dx = p.x - mx, dy = p.y - my;
      const d = dx*dx + dy*dy;
      if(d < bestD){ bestD=d; best=p; }
    }
    const hit = best && bestD <= (9*9);
    if(!hit){ hideFloatTip(); return; }
    const r = best.r;
    const why = (r.whyList && r.whyList.length) ? r.whyList.join(', ') : (r.why||'—');
    const html = `
      <div style="font-weight:700; margin-bottom:6px">Trace ${escapeHtml(String(r.traceIndex||r.trace||''))}</div>
      <div class="mono" style="opacity:.9">Peak: ${fmt(r.peakForce,3)} lb</div>
      <div class="mono" style="opacity:.9">Work: ${fmt(r.workDone,3)} • Start: ${fmt(r.startingPos,3)} • Term: ${fmt(r.terminalForce,3)}</div>
      <div style="margin-top:6px">
        <span class="chip">${r.flyer?'Flyer':'No flyer'}</span>
        <span class="chip">${r.excluded?'Excluded':'Included'}</span>
        ${r.tag?`<span class="chip">${escapeHtml(r.tag)}</span>`:''}
      </div>
      <div style="margin-top:6px; opacity:.9">Score: <span class="mono">${fmt(r.score,2)}</span> • Cause: ${escapeHtml(r.cause||'—')} • Conf: ${escapeHtml(confLabel((r.confidence!=null? r.confidence : (r.conf!=null? r.conf : 0))))}</div>
      <div style="margin-top:6px; opacity:.85">Why: ${escapeHtml(why)}</div>
    `;
    showFloatTip(html, ev.clientX, ev.clientY);
  });
}

function sortRounds(a,b){
  // Header-click sort takes precedence
  if(state.sortField){
    const f = state.sortField;
    const dir = state.sortDir === "asc" ? 1 : -1;
    const av = a[f];
    const bv = b[f];
    // booleans
    if(typeof av === "boolean" || typeof bv === "boolean"){
      const aa = av ? 1 : 0;
      const bb = bv ? 1 : 0;
      return (aa - bb) * dir;
    }
    // numbers
    if(Number.isFinite(av) || Number.isFinite(bv)){
      const aa = Number.isFinite(av) ? av : -1e18;
      const bb = Number.isFinite(bv) ? bv : -1e18;
      return (aa - bb) * dir;
    }
    // strings
    const aa = (av==null) ? "" : String(av);
    const bb = (bv==null) ? "" : String(bv);
    return aa.localeCompare(bb) * dir;
  }

  const key = state.sort;
  if(key==="score_desc") return b.score - a.score;
  if(key==="score_asc") return a.score - b.score;
  if(key==="trace_asc") return a.traceIndex - b.traceIndex;
  if(key==="trace_desc") return b.traceIndex - a.traceIndex;
  if(key==="peak_desc") return (b.peakForce??-1e9) - (a.peakForce??-1e9);
  if(key==="work_desc") return (b.workDone??-1e9) - (a.workDone??-1e9);
  if(key==="rough_desc") return (b.roughness??-1e9) - (a.roughness??-1e9);
  return b.score - a.score;
}
function confLabel(c){
  if(!Number.isFinite(c) || c<=0) return "—";
  if(c>=0.85) return "high";
  if(c>=0.65) return "med";
  return "low";
}

function diagTip(label){
  const m = {
    "Flyer":"Flyer: this trace is a mechanical outlier vs the session baseline (robust outlier test). Consider segregating or re-prepping.",
    "Force outlier":"Force outlier: Peak Force / Work / Position deviates strongly from the session median (robust z-score).",
    "Early spike":"Early spike: unusually high resistance early in seating (possible rough mouth, insufficient chamfer, or neck donut contact).",
    "Jagged":"Jagged: high curve roughness (possible carbon, inconsistent neck wall, corrosion, or damage).",
    "End flat":"End flat: reduced slope near end of seating (often normal bearing-surface behavior; watch consistency).",
    "End drop":"End drop: downward trend at end of seating (often normal; can indicate transition in bearing surface contact)."
  };
  if(m[label]) return m[label];
  if(label && label.startsWith("End")) return "End-of-stroke feature: compare consistency across the batch.";
  if(label && label.includes("ES")) return "ES rule: batch extreme spread exceeded the configured limit.";
  return "Diagnostic flag";
}
function tagTip(tag){
  if(tag==="Top5") return "Top5: one of the five HIGHEST Peak Force traces in this session (by Peak Force).";
  if(tag==="Bottom5") return "Bottom5: one of the five LOWEST Peak Force traces in this session (by Peak Force).";
  return "Tag";
}
function diagBadges(r){
  const parts = (r.diags||[]).slice();
  const flags = (r.flags||[]);
  for(const f of flags){ if(f==="Top5"||f==="Bottom5") continue; if(!parts.includes(f)) parts.push(f); }
  const out = parts.map(p=>{
    const dot = p==="Flyer" ? "bad" :
                p==="Force outlier" ? "warn" :
                (p==="Early spike" || p==="Jagged" || p.startsWith("End")) ? "mid" :
                "good";
    return `<span class="badge" title="${escapeHtml(diagTip(p))}"><span class="dot ${dot}"></span>${escapeHtml(p)}</span>`;
  });
  return out.join(" ");
}

function render(){
  const sess = getActiveSession();
  if(!sess){
    els.empty.style.display="block";
    els.tableWrap.style.display="none";
    els.kN.textContent="—"; els.kA.textContent="—"; els.kPF.textContent="—"; els.kCurve.textContent="—";
    els.sessLabel.textContent="—"; els.sessLabel.title="—"; els.sessMeta.textContent="—";
    els.curveChip.textContent="Curve: —";
    els.baseChip.textContent = `Baseline: ${state.baselineMode}`;
    els.showChip.textContent = "Shown: —";
    if(els.filterChip){ els.filterChip.style.display="none"; els.filterChip.textContent="Filters: —"; }
    return;
  }

  els.empty.style.display="none";
  els.tableWrap.style.display="block";

  // header label (ellipsis)
  els.sessLabel.textContent = sess.name;
  els.sessLabel.title = sess.name;
  els.sessMeta.textContent = `${sess.summary.n} rounds • ${sess.summary.anomalies} anomalies • ${sess.summary.flyers||0} flyers • Peak ES ${(sess.summary.peakES==null?'—':fmt(sess.summary.peakES,1))}lb`;
  els.curveChip.textContent = `Curve: ${sess.hasCurves ? "yes" : "no"}`;
  els.baseChip.textContent = `Baseline: ${state.baselineMode === "custom" ? (state.baseline ? "saved" : "none") : state.baselineMode}`;
  els.kN.textContent = sess.summary.n;
  els.kA.textContent = sess.rounds.filter(r=>r.score>=state.threshold).length;
  els.kPF.textContent = (sess.summary.peakMed==null) ? "—" : fmt(sess.summary.peakMed,3);
  els.kCurve.textContent = sess.hasCurves ? "yes" : "no";

  // sync trace chart controls
  if(els.tcOverlayWork) els.tcOverlayWork.checked = !!state.traceChart.overlayWork;
  if(els.tcUseFiltered) els.tcUseFiltered.checked = !!state.traceChart.useFiltered;
  if(els.tcShowExcluded) els.tcShowExcluded.checked = !!state.traceChart.showExcluded;

  const isActionable = (r)=> (r.score>=state.threshold) || !!r.flyer || !!r.excluded;

  const rows = sess.rounds
    .filter(r=>(!state.onlyAnom || r.score>=state.threshold))
    .filter(r=>(!state.onlyActionable || isActionable(r)))
    .filter(r=>(!state.hideExcluded || !r.excluded))
    .filter(r=>matchesQuery(r, state.query))
    .slice()
    .sort(sortRounds);

  state.shownRows = rows;
  els.showChip.textContent = `Shown: ${rows.length}`;
  // active filter indicator
  if(els.filterChip){
    const f=[];
    if(state.onlyActionable) f.push("Actionable");
    if(state.onlyAnom) f.push("Anomalies");
    if(state.hideExcluded) f.push("No excluded");
    if(state.q && String(state.q).trim()) f.push("Search");
    els.filterChip.style.display = f.length ? "inline-flex" : "none";
    els.filterChip.textContent = `Filters: ${f.length ? f.join(" + ") : "—"}`;
  }

  const body = rows.map((r,i)=>{
    const cls = clsFromScore(r.score);
    const flyerTxt = r.flyer ? "true" : "false";
    const conf = confLabel(r.conf);
    const early = (r.diagStrength && r.diagStrength.earlySpike) ? strengthGlyph(r.diagStrength.earlySpike) : (r.earlySpike!=null ? "•" : "—");
    const rough = (r.diagStrength && r.diagStrength.jagged) ? strengthGlyph(r.diagStrength.jagged) : (r.roughness!=null ? "•" : "—");
    const flat  = (r.diagStrength && r.diagStrength.endFlat) ? strengthGlyph(r.diagStrength.endFlat) : (r.endFlat!=null ? "•" : "—");
    const drop  = (r.diagStrength && r.diagStrength.endDrop) ? strengthGlyph(r.diagStrength.endDrop) : (r.endDrop!=null ? "•" : "—");
    const earlyTip = (r.z && r.z.earlySpike!=null) ? `Early spike z=${fmt(r.z.earlySpike,2)}` : (r.earlySpike!=null ? `Early spike=${fmt(r.earlySpike,3)}` : "Early spike: —");
    const roughTip = (r.z && r.z.roughness!=null) ? `Jaggedness z=${fmt(r.z.roughness,2)}` : (r.roughness!=null ? `Jaggedness=${fmt(r.roughness,4)}` : "Jaggedness: —");
    const flatTip  = (r.z && r.z.endFlat!=null) ? `End flat z=${fmt(r.z.endFlat,2)}` : (r.endFlat!=null ? `End flat=${fmt(r.endFlat,4)}` : "End flat: —");
    const dropTip  = (r.z && r.z.endDrop!=null) ? `End drop z=${fmt(r.z.endDrop,2)}` : (r.endDrop!=null ? `End drop=${fmt(r.endDrop,4)}` : "End drop: —");
    const exTxt = r.excluded ? "true" : "false";
    const tagHtml = (r.tag ? r.tag.split(";").filter(Boolean) : []).map(tg=>{
      const tip = (tg==="Top5") ? "Tag: one of the five HIGHEST Peak Force traces in this session"
                : (tg==="Bottom5") ? "Tag: one of the five LOWEST Peak Force traces in this session"
                : "Tag";
      const dot = (tg==="Top5") ? "good" : (tg==="Bottom5") ? "mid" : "warn";
      return `<span class="badge" title="${escapeHtml(tip)}"><span class="dot ${dot}"></span>${escapeHtml(tg)}</span>`;
    }).join(" ") || "—";
    return `<tr class="${cls} ${r.excluded?'excluded':''}" data-idx="${i}">
      <td class="mono">${escapeHtml(r.trace)}</td>
      <td><span class="badge" title="Flyer: mechanical outlier vs session baseline (force/position/work)."><span class="dot ${r.flyer?'bad':'good'}"></span>${flyerTxt}</span></td>
      <td><span class="badge" title="Excluded: removed by ES rule or manual exclusion; still tracked for review/export."><span class="dot ${r.excluded?'warn':'good'}"></span>${exTxt}</span></td>
      <td>${tagHtml}</td>
      <td><span title="${escapeAttr(r.whyLine||r.causeExplain||'—')}">${diagBadges(r)}</span></td>
      <td><span title="${escapeAttr(r.causeExplain||'—')}">${escapeHtml((r.cause && r.cause!=='—') ? r.cause : (r.noCurveData ? '— (no curve data)' : '—'))}</span></td>
      <td><span class="badge" title="Confidence: how strongly the data supports the Cause label."><span class="dot ${conf==='high'?'bad':conf==='med'?'warn':conf==='low'?'mid':'good'}"></span>${conf}</span></td>
      <td class="mono">${fmt(r.score,2)}</td>
      <td>${escapeHtml(r.driver)}</td>
      <td class="mono">${fmt(r.peakForce,3)}</td>
      <td class="mono">${fmt(r.workDone,3)}</td>
      <td class="mono">${fmt(r.startingPos,3)}</td>
      <td class="mono">${fmt(r.terminalForce,3)}</td>
      <td class="mono" title="${escapeAttr(earlyTip)}">${early}</td>
      <td class="mono" title="${escapeAttr(roughTip)}">${rough}</td>
      <td class="mono" title="${escapeAttr(flatTip)}">${flat}</td>
      <td class="mono" title="${escapeAttr(dropTip)}">${drop}</td>
    </tr>`;
  }).join("");

  els.tbody.innerHTML = body;
  if(els.btnClearSort){
    const on = !!state.sortField;
    els.btnClearSort.disabled = !on;
    els.btnClearSort.style.opacity = on ? 1 : 0.55;
  }
  renderTraceChart();
}

/* ========== export ========== */
function csvCell(v){
  const s = String(v ?? "");
  if(/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
  return s;
}
function buildShownCSV(){
  const rows = state.shownRows || [];
  if(!rows.length) return "";
  const header = ["Session","Trace","Flyer","Excluded","Tag","Bucket","Score","Driver","Why","Cause","Confidence",
    "Peak Force","Work Done","Starting Pos","Terminal Force","Early Spike","Jaggedness","End Flat","End Drop"];
  const lines = exportPreambleLines("sessions_summary").concat([header.join(",")]);
  const sess = getActiveSession();
  for(const r of rows){
    lines.push([
      sess ? sess.name : "",
      r.trace,
      r.flyer ? "Yes" : "No",
      r.excluded ? "Yes" : "No",
      r.tag || "",
      clsFromScore(r.score),
      fmt(r.score,2),
      r.driver || "",
      ((r.diags||[]).concat(r.flags||[])).filter((v,i,a)=>a.indexOf(v)===i).join("; "),
      r.cause || "",
      confLabel((r.confidence!=null? r.confidence : (r.conf!=null? r.conf : 0))),
      r.peakForce==null? "" : r.peakForce,
      r.workDone==null? "" : r.workDone,
      r.startingPos==null? "" : r.startingPos,
      r.terminalForce==null? "" : r.terminalForce,
      r.earlySpike==null? "" : r.earlySpike,
      r.roughness==null? "" : r.roughness,
      r.endFlat==null? "" : r.endFlat,
      r.endDrop==null? "" : r.endDrop
    ].map(csvCell).join(","));
  }
  return lines.join("\n");
}

function exportShown(){
  const csv = buildShownCSV();
  if(!csv) return;
  const blob = new Blob([csv], {type:"text/csv"});
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url;
  a.download = "amp_anomaly_shown.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

function flashStatus(msg){
  try{
    const el = document.getElementById('showChip');
    if(!el) return;
    const prev = el.textContent;
    el.textContent = msg;
    el.style.background = 'rgba(255,255,255,.16)';
    setTimeout(()=>{ el.textContent = prev; el.style.background = ''; }, 1800);
  }catch(e){}
}

async function copyShown(){
  const csv = buildShownCSV();
  if(!csv) return;
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(csv);
      flashStatus("Copied CSV ✓");
      return;
    }
  }catch(e){}
  // Fallback
  try{
    const ta = document.createElement('textarea');
    ta.value = csv;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    ta.style.top = '0';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    document.execCommand('copy');
    ta.remove();
    flashStatus("Copied CSV ✓");
  }catch(e){
    flashStatus("Copy failed");
  }
}

function clearHeaderSort(){
  state.sortField = null;
  state.sortDir = null;
  document.querySelectorAll('th').forEach(x=>x.classList.remove('sortedAsc','sortedDesc'));
  saveSettings();
  render();
}


/* ========== file loading ========== */
async function loadFiles(fileList){
  const files = Array.from(fileList || []);
  if(!files.length) return;
  const newSessions = [];
  for(const f of files){
    const txt = await f.text();
    const rows = parseCSV(txt);
    try{
      const sess = buildSession(rows, f.name);
      newSessions.push(sess);
    }catch(e){
      console.warn("Parse failed", f.name, e);
      alert(`Parse failed for ${f.name}:\n${e.message || e}`);
    }
  }
  if(!newSessions.length) return;
  newSessions.forEach(s=>recomputeSessionPostFlags(s));
  state.sessions = state.sessions.concat(newSessions);
  state.activeIndex = state.sessions.length - newSessions.length; // jump to first newly added
  renderSessionOptions();
  render();
}

/* ========== wiring ========== */
els.fileIn.addEventListener('change', (e)=>loadFiles(e.target.files));

els.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); els.drop.style.filter="brightness(1.1)"; });
els.drop.addEventListener('dragleave', ()=>{ els.drop.style.filter=""; });
els.drop.addEventListener('drop', (e)=>{
  e.preventDefault(); els.drop.style.filter="";
  loadFiles(e.dataTransfer.files);
});

els.sessionSel.addEventListener('change', ()=>{
  state.activeIndex = Number(els.sessionSel.value)||0;
  // recompute scores because threshold might change (flyer already done)
  render();
});
els.th.addEventListener('input', ()=>{
  state.threshold = Number(els.th.value);
  els.thVal.textContent = state.threshold.toFixed(2);
  saveSettings();
  render();
});

els.es.addEventListener('input', ()=>{
  state.esLimit = Number(els.es.value);
  els.esVal.textContent = String(state.esLimit);
  // recompute ES exclusions/tags for all sessions
  state.sessions = state.sessions.map(s=>recomputeSessionPostFlags(s));
  saveSettings();
  render();
});
els.esAuto.addEventListener('change', ()=>{
  state.esAutoExclude = els.esAuto.checked;
  state.sessions = state.sessions.map(s=>recomputeSessionPostFlags(s));
  saveSettings();
  render();
});
els.hideEx.addEventListener('change', ()=>{
  state.hideExcluded = els.hideEx.checked;
  saveSettings();
  render();
});
els.tabRounds.addEventListener('click', ()=>{
  state.view='rounds';
  els.tabRounds.classList.add('active'); els.tabSessions.classList.remove('active'); if(els.tabCorr) els.tabCorr.classList.remove('active');
  els.tableWrap.style.display = (getActiveSession() ? 'block':'none');
  els.sessionsWrap.style.display = 'none';
});
els.tabSessions.addEventListener('click', ()=>{
  state.view='sessions';
  els.tabSessions.classList.add('active'); els.tabRounds.classList.remove('active');
  els.sessionsWrap.style.display = (state.sessions.length ? 'block':'none');
  els.tableWrap.style.display = 'none';
  renderSessionsView();
});
els.btnExportSessions.addEventListener('click', exportSessionsCSV);

// Correlation tab removed for now (ShotLedger integration pending).
// (Code retained but not bound unless the Correlation UI exists.)
if (els.tabCorr && els.corrWrap) {
  els.tabCorr.addEventListener('click', ()=>{
    state.view='corr';
    els.tabCorr.classList.add('active'); els.tabRounds.classList.remove('active'); els.tabSessions.classList.remove('active');
    els.corrWrap.style.display = 'block';
    els.tableWrap.style.display = 'none';
    els.sessionsWrap.style.display = 'none';
    renderCorrelationView();
  });
  if(els.corrFile) els.corrFile.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(f) handleCorrFile(f);
    e.target.value = '';
  });
  if(els.btnCorrClear) els.btnCorrClear.addEventListener('click', ()=>{
    state.shotLedger = null;
    if(els.corrTbody) els.corrTbody.innerHTML = '';
    renderCorrelationView();
  });
}


function inferColumn(objKeys, needles){
  const keys = objKeys.map(k=>({k, lk:k.toLowerCase().replace(/\s+/g,'')}));
  for(const n of needles){
    const nn = n.toLowerCase().replace(/\s+/g,'');
    const found = keys.find(x=>x.lk===nn) || keys.find(x=>x.lk.includes(nn));
    if(found) return found.k;
  }
  return null;
}
function parseSimpleCSV(text){
  const lines = text.replace(/\r/g,'').split('\n').filter(l=>l.trim().length);
  if(lines.length<2) return [];
  const delim = (lines[0].includes('\t') && !lines[0].includes(',')) ? '\t' : ',';
  const headers = lines[0].split(delim).map(h=>h.trim());
  const rows = [];
  for(let i=1;i<lines.length;i++){
    const parts = lines[i].split(delim);
    const o={};
    headers.forEach((h,idx)=>{ o[h]= (parts[idx]??'').trim(); });
    rows.push(o);
  }
  return rows;
}
function readAsText(file){
  return new Promise((res,rej)=>{
    const fr = new FileReader();
    fr.onload = ()=>res(String(fr.result||''));
    fr.onerror = ()=>rej(new Error('read failed'));
    fr.readAsText(file);
  });
}
function pearson(xs, ys){
  const n = Math.min(xs.length, ys.length);
  if(n<3) return NaN;
  let sx=0, sy=0, sxx=0, syy=0, sxy=0;
  for(let i=0;i<n;i++){
    const x=xs[i], y=ys[i];
    sx+=x; sy+=y; sxx+=x*x; syy+=y*y; sxy+=x*y;
  }
  const cov = (sxy/n) - (sx/n)*(sy/n);
  const vx = (sxx/n) - (sx/n)*(sx/n);
  const vy = (syy/n) - (sy/n)*(sy/n);
  const den = Math.sqrt(vx*vy);
  return den>0 ? (cov/den) : NaN;
}
function buildCorrelationPoints(){
  const sess = getActiveSession();
  if(!sess || !sess.rounds || !sess.rounds.length) { state.corr.last = {traceKey:null, vertKey:null, matched:0, total:0}; return []; }
  if(!state.shotLedger || !state.shotLedger.rows || !state.shotLedger.rows.length) { state.corr.last = {traceKey:null, vertKey:null, matched:0, total:sess.rounds.length}; return []; }

  const rows = state.shotLedger.rows;
  const keys = Object.keys(rows[0]||{});

  // detect vertical column (ShotMarker exports often use "Vert (MOA)")
  const vertKey = inferColumn(keys, ['vert(moa)','vert','vertical(moa)','vertical','verticalmoa','verticalin','vmoa','vin','v']);

  // choose join key
  let joinMode = (els.corrJoin && els.corrJoin.value) ? els.corrJoin.value : 'auto';
  let traceKey = null;

  if(joinMode === 'amp'){
    traceKey = inferColumn(keys, ['amp#','amp #','amp no','amp number','amp']);
  } else if(joinMode === 'shot'){
    traceKey = inferColumn(keys, ['shot#','shot #','shotno','shot no','shot']);
  } else if(joinMode === 'instring'){
    traceKey = inferColumn(keys, ['#instring','# in string','instring','stringindex','indexinstring']);
  } else {
    // auto preference order: AMP # (best), Shot #, # in String, then generic trace-like fields
    traceKey =
      inferColumn(keys, ['amp#','amp #','amp no','amp number']) ||
      inferColumn(keys, ['shot#','shot #','shotno','shot no']) ||
      inferColumn(keys, ['#instring','# in string','instring','stringindex']) ||
      inferColumn(keys, ['trace','traceno','trace#','round','round#','index']);
  }

  state.corr.last = {traceKey, vertKey, matched:0, total:sess.rounds.length};

  if(!traceKey || !vertKey) return [];

  // map shotledger by join number
  const map = new Map();
  rows.forEach(r=>{
    const t = Number(String(r[traceKey]??'').replace(/[^0-9.\-]/g,''));
    const v = Number(String(r[vertKey]??'').replace(/[^0-9.\-]/g,''));
    if(Number.isFinite(t) && Number.isFinite(v)) map.set(t, v);
  });

  const pts=[];
  sess.rounds.forEach(r=>{
    const t = Number(r.traceIndex||r.trace||r.traceNo||r.traceNum);
    if(!Number.isFinite(t)) return;
    if(!Number.isFinite(r.peakForce)) return;
    if(!map.has(t)) return;
    pts.push({trace:t, x:r.peakForce, y:map.get(t), flyer:!!r.flyer, excluded:!!r.excluded, r});
  });

  state.corr.last.matched = pts.length;
  return pts;
}
function renderCorrelationView(){
  if(!els.corrWrap) return;
  const sess = getActiveSession();
  const pts = buildCorrelationPoints();
  state.corr.points = pts;

  // status chips
  if(!state.shotLedger){
    els.corrStatus.textContent = 'No ShotLedger file loaded';
    els.corrStatus.title = 'Import a ShotLedger/ShotMarker export (CSV/TSV) that contains a join column (AMP # or Shot #) and a vertical column (e.g., Vert (MOA)).';
  } else {
    const last = state.corr.last || {};
    const joinLabel = last.traceKey ? `join: ${last.traceKey}` : 'join: —';
    const vertLabel = last.vertKey ? `vert: ${last.vertKey}` : 'vert: —';
    const matchLabel = (Number.isFinite(last.matched) && Number.isFinite(last.total)) ? `matched ${last.matched}/${last.total}` : '';
    els.corrStatus.textContent = `ShotLedger loaded • ${matchLabel}`;
    els.corrStatus.title = `${state.shotLedger.name||''}
${joinLabel} • ${vertLabel}`;
  }

  // table
  if(els.corrTbody){
    els.corrTbody.innerHTML = pts.map(p=>`
      <tr>
        <td class="mono">Trace ${p.trace}</td>
        <td class="mono">${fmt(p.x,3)}</td>
        <td class="mono">${fmt(p.y,3)}</td>
        <td><span class="pill ${p.flyer?'bad':'ok'}">${p.flyer?'true':'false'}</span></td>
        <td><span class="pill ${p.excluded?'warn':'ok'}">${p.excluded?'true':'false'}</span></td>
      </tr>
    `).join('') || `<tr><td colspan="5" class="small">No matched points yet. Import a CSV with Trace and Vertical columns.</td></tr>`;
  }

  // chart
  const c = els.corrChart;
  if(!c) return;
  // ensure canvas matches displayed size (important when switching tabs)
  const rect = c.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const wantW = Math.max(320, Math.floor(rect.width * dpr));
  const wantH = Math.max(240, Math.floor(rect.height * dpr));
  if(c.width !== wantW || c.height !== wantH){ c.width = wantW; c.height = wantH; }
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);

  if(!sess){
    ctx.fillStyle='rgba(255,255,255,.55)'; ctx.font='14px ui-sans-serif';
    ctx.fillText('Load a session to view correlation.', 12, 22);
    return;
  }
  if(!pts.length){
    ctx.fillStyle='rgba(255,255,255,.55)'; ctx.font='14px ui-sans-serif';
    ctx.fillText('Import a ShotLedger CSV with Trace + Vertical to plot correlation.', 12, 22);
    return;
  }

  const xs = pts.map(p=>p.x), ys = pts.map(p=>p.y);
  const r = pearson(xs, ys);
  els.corrStats.textContent = Number.isFinite(r) ? ('r: '+fmt(r,3)) : 'r: —';
  els.corrStats.title = Number.isFinite(r) ? 'Pearson correlation (Peak Force vs Vertical)' : '—';

  const xPad=34, yPad=18, plotW=W-xPad-18, plotH=H-yPad-26;
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const padX=(maxX-minX)*0.08 || 1;
  const padY=(maxY-minY)*0.10 || 1;
  const x0=minX-padX, x1=maxX+padX;
  const y0=minY-padY, y1=maxY+padY;
  const X = (v)=> xPad + ((v-x0)/(x1-x0))*plotW;
  const Y = (v)=> yPad + (1-((v-y0)/(y1-y0)))*plotH;

  // axes
  ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(xPad, yPad); ctx.lineTo(xPad, yPad+plotH); ctx.lineTo(xPad+plotW, yPad+plotH); ctx.stroke();
  ctx.fillStyle='rgba(255,255,255,.55)'; ctx.font='12px ui-sans-serif';
  ctx.fillText('Peak Force (lb)', xPad+6, yPad+plotH+18);
  ctx.save(); ctx.translate(12, yPad+plotH/2); ctx.rotate(-Math.PI/2); ctx.fillText('Vertical (units)', 0, 0); ctx.restore();

  // regression line (simple least squares)
  let sx=0, sy=0, sxx=0, sxy=0, n=pts.length;
  pts.forEach(p=>{ sx+=p.x; sy+=p.y; sxx+=p.x*p.x; sxy+=p.x*p.y; });
  const denom = (n*sxx - sx*sx);
  if(Math.abs(denom)>1e-9){
    const m = (n*sxy - sx*sy)/denom;
    const b = (sy - m*sx)/n;
    const yA = m*x0 + b, yB = m*x1 + b;
    ctx.strokeStyle='rgba(255,255,255,.18)'; ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(X(x0), Y(yA)); ctx.lineTo(X(x1), Y(yB)); ctx.stroke(); ctx.setLineDash([]);
  }

  // points
  pts.forEach(p=>{
    const xx=X(p.x), yy=Y(p.y);
    let fill='rgba(124,220,255,.90)', rad=4, stroke=null, lw=2;
    if(p.excluded){ fill='rgba(200,200,210,.55)'; rad=3.5; }
    if(p.flyer){ stroke='rgba(255,85,85,.95)'; lw=2.5; }
    ctx.beginPath(); ctx.fillStyle=fill; ctx.arc(xx,yy,rad,0,Math.PI*2); ctx.fill();
    if(stroke){ ctx.strokeStyle=stroke; ctx.lineWidth=lw; ctx.stroke(); }
  });
}

async function handleCorrFile(file){
  try{
    const txt = await readAsText(file);
    const rows = parseSimpleCSV(txt);
    state.shotLedger = { name: file.name, rows };
    renderCorrelationView();
  } catch(e){
    alert('Could not read correlation file.');
  }
}

// Trace chart controls
initTraceChartHover();

if(els.tcOverlayWork) els.tcOverlayWork.addEventListener('change', ()=>{ state.traceChart.overlayWork = els.tcOverlayWork.checked; renderTraceChart(); });
if(els.tcUseFiltered) els.tcUseFiltered.addEventListener('change', ()=>{ state.traceChart.useFiltered = els.tcUseFiltered.checked; renderTraceChart(); });
if(els.tcShowExcluded) els.tcShowExcluded.addEventListener('change', ()=>{ state.traceChart.showExcluded = els.tcShowExcluded.checked; renderTraceChart(); });


els.onlyAnom.addEventListener('change', ()=>{ state.onlyAnom = els.onlyAnom.checked; saveSettings(); render(); });
els.onlyActionable.addEventListener('change', ()=>{ state.onlyActionable = els.onlyActionable.checked; saveSettings(); render(); });
els.q.addEventListener('input', ()=>{ state.query = els.q.value.trim(); saveSettings(); render(); });
els.sortSel.addEventListener('change', ()=>{
  const v = els.sortSel.value;
  if(v === 'custom'){
    // Only meaningful if a header sort is active
    if(!state.sortField){
      // revert to previous non-custom choice
      els.sortSel.value = state.sort && state.sort !== 'custom' ? state.sort : 'score_desc';
    } else {
      state.sort = 'custom';
    }
    saveSettings();
    render();
    return;
  }
  state.sort = v;
  state.sortField = null;
  state.sortDir = null;
  document.querySelectorAll('th').forEach(x=>x.classList.remove('sortedAsc','sortedDesc'));
  saveSettings();
  render();
});

els.baseSel.addEventListener('change', ()=>{
  state.baselineMode = els.baseSel.value;
  saveSettings();
  render();
});
els.btnSaveBase.addEventListener('click', ()=>{
  const sess = getActiveSession();
  if(!sess) return;
  state.baseline = sessionToBaseline(sess);
  saveBaseline(state.baseline);
  state.baselineMode = "custom";
  els.baseSel.value = "custom";
  render();
});
els.btnClrBase.addEventListener('click', ()=>{
  state.baseline = null;
  clearBaseline();
  if(state.baselineMode==="custom"){
    state.baselineMode = "none";
    els.baseSel.value = "none";
  }
  render();
});

els.btnExport.addEventListener('click', exportShown);
els.btnCopy && els.btnCopy.addEventListener('click', copyShown);
els.btnClearSort && els.btnClearSort.addEventListener('click', clearHeaderSort);
els.btnReset && els.btnReset.addEventListener('click', ()=>{
  resetDefaults();
  // if ES auto-exclude changed, recompute flags
  state.sessions = state.sessions.map(s=>recomputeSessionPostFlags(s));
  render();
});

els.btnExportJSON && els.btnExportJSON.addEventListener('click', exportJSON);

els.btnImportJSON && els.btnImportJSON.addEventListener('click', ()=>{
  if(els.jsonIn) els.jsonIn.click();
});

els.jsonIn && els.jsonIn.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  try{
    const text = await f.text();
    importJSONText(text);
  }catch(err){
    alert("Couldn't read that file.");
  }finally{
    // allow re-importing the same filename
    e.target.value = "";
  }
});


els.btnClear.addEventListener('click', ()=>{
  state.sessions = [];
  state.activeIndex = 0;
  els.sessionSel.innerHTML="";
  render();
});

/* ========== init baseline + render ========== */
state.baseline = loadBaseline();
// load persisted view settings
applySettingsToStateAndUI(loadSettings());
setupHeaderSort();
render();

// Small hint to show injection warning if console shows the secdomcheck pattern
(function(){
  const orig = console.error;
  console.error = function(...args){
    try{
      const s = args.map(a=>String(a)).join(" ");
      if(s.includes("secdomcheck.online") || s.includes("doubleview.online") || s.includes("topodat.info")){
        els.injWarn.style.display="block";
      }
    }catch(e){}
    return orig.apply(console, args);
  };
})();
</script>

<div id="floatTip" style="position:fixed; display:none; z-index:50; max-width:360px; background:rgba(8,12,20,.92); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:10px 10px; box-shadow:0 10px 30px rgba(0,0,0,.35); font-size:12px; color:rgba(255,255,255,.92); pointer-events:none"></div>
</body>
</html>
