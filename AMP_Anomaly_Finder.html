
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AMP CSV Anomaly + Curve Diagnostics</title>
<style>
  :root{
    --bg0:#0b1220; --bg1:#0f1b2e; --card:#0f2234cc; --card2:#0b1a2b;
    --txt:#e6eef7; --mut:#9bb0c8; --line:#1f3550;
    --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --mid:#38bdf8; --hi:#a78bfa;
  }
  *{box-sizing:border-box}
  body{
    margin:0; color:var(--txt); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background:
      radial-gradient(1100px 600px at 20% -10%, rgba(56,189,248,.18), transparent 60%),
      radial-gradient(1000px 600px at 85% 0%, rgba(167,139,250,.14), transparent 55%),
      linear-gradient(180deg, var(--bg0), #050914);
    min-height:100vh;
  }
  header{
    padding:18px 18px 10px;
    display:flex; gap:12px; align-items:flex-end; justify-content:space-between;
  }
  header h1{margin:0; font-size:18px; letter-spacing:.2px}
  header .sub{margin:2px 0 0; color:var(--mut); font-size:12px}
  header .right{display:flex; gap:10px; align-items:center}
  .pill{
    font-size:12px; color:var(--mut); border:1px solid var(--line); padding:6px 10px; border-radius:999px;
    background:rgba(15,34,52,.55);
  }
  main{display:grid; grid-template-columns: 340px 1fr; gap:14px; padding:0 14px 16px;}
  .card{
    border:1px solid rgba(31,53,80,.7);
    background: linear-gradient(180deg, rgba(15,34,52,.72), rgba(11,26,43,.62));
    box-shadow: 0 12px 30px rgba(0,0,0,.25);
    border-radius:16px;
    overflow:hidden;
  }
  .card h2{margin:0; padding:12px 14px; font-size:13px; letter-spacing:.2px; border-bottom:1px solid rgba(31,53,80,.6); color:#d8e6f8}
  .card .body{padding:12px 14px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .btn{
    background:#12314c; border:1px solid rgba(56,189,248,.35);
    color:var(--txt); padding:8px 10px; border-radius:12px; cursor:pointer; font-weight:600; font-size:12px;
  }
  .btn:hover{filter:brightness(1.08)}
  .btn.secondary{background:transparent; border:1px solid rgba(31,53,80,.9); color:var(--mut)}
  input[type="file"]{display:none}
  .drop{
    border:1px dashed rgba(56,189,248,.45);
    border-radius:14px; padding:12px; background:rgba(3,11,22,.35);
    color:var(--mut); font-size:12px;
  }
  .drop strong{color:var(--txt)}
  .kv{display:grid; grid-template-columns: 1fr auto; gap:6px 10px; margin-top:10px; font-size:12px}
  .kv div:nth-child(odd){color:var(--mut)}
  .kv div:nth-child(even){font-variant-numeric: tabular-nums;}
  .control{margin-top:10px}
  label{font-size:12px; color:var(--mut)}
  input[type="range"]{width:100%}
  select, input[type="text"]{
    width:100%;
    background:rgba(3,11,22,.5);
    border:1px solid rgba(31,53,80,.85);
    color:var(--txt);
    padding:9px 10px; border-radius:12px; outline:none;
  }
  select:focus, input[type="text"]:focus{border-color:rgba(56,189,248,.65)}
  .hint{font-size:12px; color:var(--mut); line-height:1.35}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
  .split{display:flex; gap:10px}
  .split > *{flex:1}
  .tog{display:flex; align-items:center; gap:8px; margin-top:8px; font-size:12px; color:var(--mut)}
  .tog input{transform: translateY(1px)}
  .badges{display:flex; gap:6px; flex-wrap:wrap}
  .badge{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border-radius:999px; font-size:11px; border:1px solid rgba(31,53,80,.8);
    background:rgba(3,11,22,.35); color:var(--mut);
  }
  .dot{width:8px; height:8px; border-radius:999px; display:inline-block}
  .dot.good{background:var(--good)}
  .dot.mid{background:var(--mid)}
  .dot.hi{background:var(--hi)}
  .dot.warn{background:var(--warn)}
  .dot.bad{background:var(--bad)}
  /* Right side table */
  .tableWrap{overflow:auto; overflow-x:auto; max-height: calc(100vh - 120px);}
  .tableWrap table{min-width: 1400px;}
  table{width:100%; border-collapse:separate; border-spacing:0; font-size:12px}
  thead th{
    position:sticky; top:0; z-index:2;
    background:rgba(9,20,34,.95);
    border-bottom:1px solid rgba(31,53,80,.9);
    padding:10px 10px; text-align:left; color:#cfe1f5; font-weight:700;
    white-space:nowrap;
  }
  tbody td{
    border-bottom:1px solid rgba(31,53,80,.35);
    padding:8px 10px; vertical-align:middle;
  }
  tbody tr:hover{background:rgba(56,189,248,.06)}
  tbody tr.normal{background:transparent}
  tbody tr.moderate{background:rgba(56,189,248,.06)}
  tbody tr.high{background:rgba(245,158,11,.08)}
  tbody tr.flyer{background:rgba(239,68,68,.10)}
  .sessionBar{
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    padding:10px 14px; border-bottom:1px solid rgba(31,53,80,.6);
  }
  .sessionPill{
    display:flex; align-items:center; gap:8px;
    border:1px solid rgba(31,53,80,.85);
    background:rgba(3,11,22,.35);
    padding:8px 10px; border-radius:999px; max-width:100%;
    min-width:0;
  }
  .sessionPill .label{
    min-width:0; max-width:100%;
    overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    font-size:12px; color:var(--txt); font-weight:700;
  }
  .sessionPill .meta{font-size:11px; color:var(--mut); white-space:nowrap}
  .chip{
    font-size:11px; color:var(--mut); border:1px solid rgba(31,53,80,.8);
    padding:4px 8px; border-radius:999px; background:rgba(3,11,22,.25);
  }
  .warnBox{
    margin:12px 14px; padding:12px; border-radius:14px;
    border:1px solid rgba(245,158,11,.35);
    background:rgba(245,158,11,.08); color:#f7d9a5;
  }
  .kbd{font-family:ui-monospace; font-size:11px; padding:1px 6px; border:1px solid rgba(31,53,80,.9); border-radius:6px; background:rgba(3,11,22,.35); color:var(--mut)}
  .small{font-size:11px; color:var(--mut)}
  .nowrap{white-space:nowrap}

/* v2.1 patches */
.control select{max-width:100%; width:100%;}
.sessionPill .label{min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:block;}
tr.excluded{opacity:.55;}
.viewTabs{display:flex; gap:8px; align-items:center;}
.viewTabs .tabbtn{padding:7px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:var(--txt); cursor:pointer; font-weight:600;}
.viewTabs .tabbtn.active{background:rgba(124,220,255,.18); border-color:rgba(124,220,255,.35);}
.sessionsWrap{display:none;}
.sessionsWrap table{width:100%; border-collapse:separate; border-spacing:0 10px;}
.sessionsWrap th{font-size:12px; color:var(--mut); text-align:left; padding:0 10px;}
.sessionsWrap td{padding:10px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08);}
.sessionsWrap tr:hover td{background:rgba(255,255,255,.06); cursor:pointer;}


  th.sortedAsc::after{content:' ▲'; opacity:.7;}
  th.sortedDesc::after{content:' ▼'; opacity:.7;}

.tableWrap{ overflow:auto; }
.tableWrap table{ min-width: 1200px; }
.tableWrap thead th:nth-child(1),
.tableWrap tbody td:nth-child(1){
  position: sticky; left: 0; 
  min-width:120px; width:120px;
}
.tableWrap thead th:nth-child(1){ z-index: 7; background: rgba(10,16,28,.98); }
.tableWrap tbody td:nth-child(1){ z-index: 4; background: rgba(8,12,18,.96); }

.tableWrap thead th:nth-child(2),
.tableWrap tbody td:nth-child(2){
  position: sticky; left: 120px;
  min-width:90px; width:90px;
}
.tableWrap thead th:nth-child(2){ z-index: 7; background: rgba(10,16,28,.98); }
.tableWrap tbody td:nth-child(2){ z-index: 4; background: rgba(8,12,18,.96); }

.tableWrap thead th:nth-child(3),
.tableWrap tbody td:nth-child(3){
  position: sticky; left: 210px;
  min-width:110px; width:110px;
}
.tableWrap thead th:nth-child(3){ z-index: 7; background: rgba(10,16,28,.98); }
.tableWrap tbody td:nth-child(3){ z-index: 4; background: rgba(8,12,18,.96); }

/* subtle divider after pinned columns */
.tableWrap thead th:nth-child(3),
.tableWrap tbody td:nth-child(3){
  box-shadow: 8px 0 18px rgba(0,0,0,.22);
}
.tableWrap tbody tr.excluded td:first-child{
  background: rgba(10,16,28,.92);
}

</style>
</head>
<body>
<header>
  <div>
    <h1>AMP CSV Anomaly Finder v3.8 v3.8 <span class="pill">offline</span></h1>
    <div class="sub">Upload AMP “Press” CSV exports (wide). Scores anomalies + adds curve diagnostics (early spike, jaggedness, end flat/drop) when curve data exists.</div>
  </div>
  <div class="right">
    <button class="btn secondary" id="btnExport">Export shown (CSV)</button>
    <button class="btn secondary" id="btnClear">Clear</button>
  </div>
</header>

<main>
  <section class="card">
    <h2>Upload & Controls</h2>
    <div class="body">
      <div class="row">
        <label class="btn" for="fileIn">Choose files</label>
        <input id="fileIn" type="file" accept=".csv,text/csv" multiple/>
      </div>

      <div id="drop" class="drop" style="margin-top:10px">
        <strong>Drop AMP CSV files here</strong><br/>
        <span class="small">Each file becomes a session. Works offline (no internet needed).</span>
      </div>

      <div class="control" style="margin-top:12px">
        <label>Session</label>
        <select id="sessionSel"></select>
        <div class="hint" style="margin-top:6px">
          Tip: AMP export is often <span class="mono">wide</span> (variables in rows, <span class="mono">Trace 1..N</span> in columns). This tool expects that.
        </div>
      </div>

      <div class="control">
        <label>Anomaly threshold: <span class="mono" id="thVal">2.50</span></label>
        <input id="th" type="range" min="0.5" max="5.0" step="0.05" value="2.5"/>
        <div class="tog"><input id="onlyAnom" type="checkbox"/><label for="onlyAnom">Only anomalies</label></div>
      
      <div class="control">
        <label>Peak Force ES limit (lb): <span class="mono" id="esVal">20</span></label>
        <input id="es" type="range" min="5" max="50" step="1" value="20"/>
        <div class="tog"><input id="esAuto" type="checkbox" checked/><label for="esAuto">Auto-exclude ES extremes (top/bottom) when limit exceeded</label></div>
        <div class="hint" style="margin-top:6px">
          ES here is <span class="mono">max(peak)-min(peak)</span> for the session. If it exceeds the limit, the max and min traces are marked <span class="mono">Excluded</span> but remain visible for learning.
        </div>
      </div>

      <div class="control">
        <div class="tog"><input id="hideEx" type="checkbox"/><label for="hideEx">Hide excluded rounds</label></div>
      </div>
</div>

      <div class="control">
        <label>Search</label>
        <input id="q" type="text" placeholder="trace, driver, cause…"/>
      </div>

      <div class="control">
        <div class="split">
          <div>
            <label>Sort</label>
            <select id="sortSel">
              <option value="custom">Custom (header click)</option>
              <option value="score_desc">Score (high → low)</option>
              <option value="score_asc">Score (low → high)</option>
              <option value="trace_asc">Trace (asc)</option>
              <option value="trace_desc">Trace (desc)</option>
              <option value="peak_desc">Peak Force (high → low)</option>
              <option value="work_desc">Work Done (high → low)</option>
              <option value="rough_desc">Roughness (high → low)</option>
            </select>
          </div>
          <div>
            <label>Baseline</label>
            <select id="baseSel">
              <option value="none">No baseline</option>
              <option value="active">Active session</option>
              <option value="custom">Saved baseline</option>
            </select>
            <div class="row" style="margin-top:8px">
              <button class="btn secondary" id="btnSaveBase" title="Save the active session medians as baseline">Save baseline</button>
              <button class="btn secondary" id="btnClrBase" title="Clear saved baseline">Clear</button>
            </div>
          </div>
        </div>
        <div class="hint" style="margin-top:8px">
          Baseline enables “Steeper slope overall” style detection by comparing session medians to your baseline.
        </div>
      </div>

      <div class="control">
        <div class="kv">
          <div>Rounds</div><div class="mono" id="kN">—</div>
          <div>Anomalies (≥ threshold)</div><div class="mono" id="kA">—</div>
          <div>Peak Force median</div><div class="mono" id="kPF">—</div>
          <div>Curve data</div><div class="mono" id="kCurve">—</div>
        </div>
      </div>

      <div class="control">
        <div class="badges">
          <span class="badge"><span class="dot good"></span> Normal</span>
          <span class="badge"><span class="dot mid"></span> Moderate</span>
          <span class="badge"><span class="dot warn"></span> High</span>
          <span class="badge"><span class="dot bad"></span> Flyer</span>
        </div>
      </div>

      <div class="control" style="margin-top:12px">
        <details>
          <summary class="hint">What diagnostics mean (click)</summary>
          <div class="hint" style="margin-top:8px">
            <div><b>Early Spike</b>: unusually high force early in the seating stroke → often chamfer/case mouth/donut.</div>
            <div><b>Jagged</b>: high “roughness” (curve jitter) → carbon/corrosion/neck-wall inconsistency.</div>
            <div><b>End Flat/Drop</b>: unusually flat or dropping end segment → bearing-surface transition; if inconsistent, investigate setup/components.</div>
            <div><b>Force Outlier</b>: Peak/Work/Terminal unusually high/low → neck tension / sizing / anneal variance.</div>
          </div>
        </details>
      </div>

      <div class="warnBox" style="display:none" id="injWarn">
        <b>Heads up:</b> Your browser appears to have a script/extension injecting ad/redirect code into pages.
        This tool runs offline and does not load remote URLs. If you see network calls to random domains, try Incognito or remove the extension.
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Rounds</h2>
    <div class="sessionBar">
      <div class="sessionPill" style="flex:1">
        <span class="chip">Session</span>
        <span class="label" id="sessLabel" title="—">—</span>
        <span class="meta" id="sessMeta">—</span>
      </div>
      <div class="viewTabs" style="margin-left:auto">
        <button class="tabbtn active" id="tabRounds" type="button">Rounds</button>
        <button class="tabbtn" id="tabSessions" type="button">Sessions</button>
      </div>
      <span class="chip" id="curveChip">Curve: —</span>
      <span class="chip" id="baseChip">Baseline: none</span>
      <span class="chip" id="showChip">Shown: —</span>
    </div>

    <div id="empty" class="warnBox">
      Upload one or more AMP CSV files to see a scored table here.
      <div class="hint">If your AMP export layout is different, paste a few header lines and I’ll adapt the parser.</div>
    </div>

    <div class="tableWrap" id="tableWrap" style="display:none">

      <div class="card" id="traceChartCard" style="margin-bottom:12px">
        <div class="row" style="justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap">
          <div>
            <div class="kTitle">Trace chart</div>
            <div class="hint">Peak Force by trace index. Highlights: <span class="mono">Flyer</span>, <span class="mono">Top5</span>/<span class="mono">Bottom5</span>, and <span class="mono">Excluded</span>.</div>
          </div>
          <div class="row" style="gap:10px; flex-wrap:wrap; justify-content:flex-end">
            <label class="row small" style="gap:6px; cursor:pointer"><input type="checkbox" id="tcOverlayWork"/> Overlay Work Done</label>
            <label class="row small" style="gap:6px; cursor:pointer"><input type="checkbox" id="tcUseFiltered"/> Use filtered view</label>
            <label class="row small" style="gap:6px; cursor:pointer"><input type="checkbox" id="tcShowExcluded" checked/> Show excluded</label>
          </div>
        </div>
        <div class="card" style="margin-top:10px; padding:10px; background:rgba(0,0,0,.12)">
          <canvas id="traceChart" width="900" height="240" style="width:100%; height:240px"></canvas>
          <div class="hint" style="margin-top:6px">Tip: click column headers to sort; chart updates for the active session.</div>
        </div>
      </div>

      <table>
        <thead>
          <tr>
            <th>Trace</th>
            <th>Flyer</th>
            <th>Excluded</th>
            <th>Tag</th>
            <th>Why</th>
            <th>Cause</th>
            <th>Conf</th>
            <th>Score</th>
            <th>Driver</th>
            <th class="nowrap">Peak Force</th>
            <th class="nowrap">Work Done</th>
            <th class="nowrap">Starting Pos</th>
            <th class="nowrap">Terminal Force</th>
            <th class="nowrap">Early Spike</th>
            <th class="nowrap">Jagged</th>
            <th class="nowrap">End Flat</th>
            <th class="nowrap">End Drop</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <div class="sessionsWrap" id="sessionsWrap">
      <div class="row" style="justify-content:space-between; align-items:center; margin:6px 0 10px">
        <div class="small">Session summary across all loaded files. Click a session row to jump back to its rounds.</div>
        <button class="btn secondary" id="btnExportSessions" type="button" title="Export session summary CSV">Export sessions (CSV)</button>
      </div>
      <div class="card" style="padding:10px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08); border-radius:14px; margin-bottom:12px">
        <canvas id="sessChart" width="900" height="220" style="width:100%; height:220px"></canvas>
        <div class="hint" style="margin-top:6px">Two lines: <span class="mono">Peak Med</span> (median Peak Force) and <span class="mono">Peak ES</span>. Each vertex is a loaded session, in session order.</div>
      </div>
      <table>
        <thead>
          <tr>
            <th>Session</th>
            <th>Rounds</th>
            <th>Flyers</th>
            <th>Anomalies</th>
            <th>Peak Med</th>
            <th>Peak ES</th>
            <th>Work Med</th>
            <th>Rough Med</th>
          </tr>
        </thead>
        <tbody id="sessionsTbody"></tbody>
      </table>
    </div>

  </section>
</main>

<script>
/* ========== small safety nudge (detect injected network calls via global fetch patch check) ========== */
(function(){
  try{
    // If some extension overwrote fetch in a weird way, it might show as non-native.
    const f = window.fetch;
    const looksNative = f && (String(f).includes('[native code]') || String(f).includes('function fetch'));
    // Not a definitive check; we only display if we already see suspicious error patterns later.
    window.__fetchLooksNative = looksNative;
  }catch(e){}
})();

/* ========== state ========== */
const state = {
  sessions: [],
  activeIndex: 0,
  threshold: 2.5,
  esLimit: 20,
  esAutoExclude: true,
  hideExcluded: false,
  view: 'rounds',
  onlyAnom: false,
  query: "",
  sort: "score_desc",
  baselineMode: "none", // none|active|custom
  baseline: null, // {metrics:{key:{med}}, curves:{key:{med}}}
  traceChart: { overlayWork:false, useFiltered:false, showExcluded:true },
  shownRows: []
};

const els = {
  fileIn: document.getElementById('fileIn'),
  drop: document.getElementById('drop'),
  sessionSel: document.getElementById('sessionSel'),
  th: document.getElementById('th'),
  thVal: document.getElementById('thVal'),
  es: document.getElementById('es'),
  esVal: document.getElementById('esVal'),
  esAuto: document.getElementById('esAuto'),
  hideEx: document.getElementById('hideEx'),
  onlyAnom: document.getElementById('onlyAnom'),
  q: document.getElementById('q'),
  sortSel: document.getElementById('sortSel'),
  baseSel: document.getElementById('baseSel'),
  btnSaveBase: document.getElementById('btnSaveBase'),
  btnClrBase: document.getElementById('btnClrBase'),
  btnExport: document.getElementById('btnExport'),
  btnClear: document.getElementById('btnClear'),
  empty: document.getElementById('empty'),
  tableWrap: document.getElementById('tableWrap'),
  tbody: document.getElementById('tbody'),
  kN: document.getElementById('kN'),
  kA: document.getElementById('kA'),
  kPF: document.getElementById('kPF'),
  kCurve: document.getElementById('kCurve'),
  sessLabel: document.getElementById('sessLabel'),
  sessMeta: document.getElementById('sessMeta'),
  tabRounds: document.getElementById('tabRounds'),
  tabSessions: document.getElementById('tabSessions'),
  sessionsWrap: document.getElementById('sessionsWrap'),
  sessionsTbody: document.getElementById('sessionsTbody'),
  btnExportSessions: document.getElementById('btnExportSessions'),
  sessChart: document.getElementById('sessChart'),
  traceChart: document.getElementById('traceChart'),
  tcOverlayWork: document.getElementById('tcOverlayWork'),
  tcUseFiltered: document.getElementById('tcUseFiltered'),
  tcShowExcluded: document.getElementById('tcShowExcluded'),
  curveChip: document.getElementById('curveChip'),
  baseChip: document.getElementById('baseChip'),
  showChip: document.getElementById('showChip'),
  curveChip2: document.getElementById('curveChip'),
  injWarn: document.getElementById('injWarn')
};

/* ========== utils ========== */
function toNum(x){
  if(x==null) return null;
  const s = String(x).trim().replace(/,/g,''); // tolerate thousands separators
  if(s==="") return null;
  const v = Number(s);
  return Number.isFinite(v) ? v : null;
}
function fmt(v, d=3){
  if(!Number.isFinite(v)) return "—";
  return Number(v).toFixed(d);
}
function median(arr){
  const a = arr.filter(v=>Number.isFinite(v)).slice().sort((x,y)=>x-y);
  const n = a.length;
  if(!n) return null;
  const mid = Math.floor(n/2);
  return n%2 ? a[mid] : (a[mid-1]+a[mid])/2;
}
function mad(arr, med){
  const dev = arr.filter(v=>Number.isFinite(v)).map(v=>Math.abs(v-med));
  return median(dev);
}
function mean(arr){
  const a = arr.filter(v=>Number.isFinite(v));
  if(!a.length) return null;
  return a.reduce((s,v)=>s+v,0)/a.length;
}
function stdev(arr){
  const mu = mean(arr);
  if(mu==null) return null;
  const a = arr.filter(v=>Number.isFinite(v));
  if(a.length<2) return null;
  const v = a.reduce((s,x)=>s+(x-mu)**2,0)/(a.length-1);
  return Math.sqrt(v);
}
function robustZ(x, st){
  // st: {med, mad, sd, mu}
  if(!Number.isFinite(x) || st.med==null) return 0;
  if(st.mad && st.mad>0) return 0.6745*(x-st.med)/st.mad;
  if(st.sd && st.sd>0 && st.mu!=null) return (x-st.mu)/st.sd;
  return 0;
}
function clsFromScore(score){
  if(score>=3.5) return "flyer";
  if(score>=2.5) return "high";
  if(score>=1.5) return "moderate";
  return "normal";
}
function escapeHtml(s){
  return String(s??"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}
function pickDot(bucket){
  if(bucket==="flyer") return "bad";
  if(bucket==="high") return "warn";
  if(bucket==="moderate") return "mid";
  return "good";
}

/* ========== CSV parser (handles quotes) ========== */
function parseCSV(text){
  // sniff delimiter (comma vs semicolon)
  const firstLine = (text.split(/\r?\n/).find(l=>l.trim().length) || "");
  const comma = (firstLine.match(/,/g)||[]).length;
  const semi  = (firstLine.match(/;/g)||[]).length;
  const delim = semi>comma ? ';' : ',';

  const rows = [];
  let row = [];
  let cur = "";
  let inQ = false;
  for(let i=0;i<text.length;i++){
    const ch = text[i];
    if(inQ){
      if(ch === '"'){
        const next = text[i+1];
        if(next === '"'){ cur+='"'; i++; }
        else inQ = false;
      } else cur += ch;
    } else {
      if(ch === '"') inQ = true;
      else if(ch === delim){
        row.push(cur); cur="";
      } else if(ch === '\n'){
        row.push(cur); rows.push(row);
        row=[]; cur="";
      } else if(ch === '\r'){
        // ignore
      } else cur += ch;
    }
  }
  row.push(cur); rows.push(row);
  // trim trailing empty rows
  while(rows.length && rows[rows.length-1].every(c=>String(c??"").trim()==="")) rows.pop();
  return rows;
}
function isRowEmpty(r){ return !r || r.every(c=>String(c??"").trim()===""); }
function splitBlocks(rows){
  const blocks = [];
  let cur = [];
  for(const r of rows){
    if(isRowEmpty(r)){
      if(cur.length){ blocks.push(cur); cur=[]; }
    } else cur.push(r);
  }
  if(cur.length) blocks.push(cur);
  return blocks;
}

/* ========== AMP reshape ========== */
function detectTraceHeader(header){
  // Returns indices of trace columns and their names.
  const cols = [];
  for(let i=0;i<header.length;i++){
    const h = String(header[i]??"").trim();
    if(/^(trace\s*\d+|trace\d+)$/i.test(h) || /^Trace\s*\d+/i.test(h)){
      cols.push({i, name:h});
    }
  }
  // If none, try all columns after first as traces if "Trace" appears anywhere
  if(!cols.length){
    const anyTrace = header.some(h=>/trace/i.test(String(h||"")));
    if(anyTrace && header.length>=3){
      for(let i=1;i<header.length;i++){
        cols.push({i, name:String(header[i]??`Trace ${i}`).trim() || `Trace ${i}`});
      }
    }
  }
  return cols;
}

function parseMetricBlock(block){
  // wide: first row header: ["", "Trace 1", ...]
  const header = block[0].map(x => String(x??"").trim());
  const traces = header.slice(1).map((h,i)=>h||`Trace ${i+1}`);
  const n = traces.length;
  if(n<1) return null;

  // map varName -> array (len n)
  const map = new Map();
  for(let r=1;r<block.length;r++){
    const varName = String(block[r][0]??"").trim();
    if(!varName) continue;
    const vals = [];
    for(let c=1;c<1+n;c++){
      vals.push(block[r][c] ?? "");
    }
    map.set(varName, vals);
  }
  function getVar(keys){
    for(const k of keys){
      for(const [name, vals] of map.entries()){
        if(name.toLowerCase() === k.toLowerCase()) return {name, vals};
      }
    }
    for(const k of keys){
      for(const [name, vals] of map.entries()){
        if(name.toLowerCase().includes(k.toLowerCase())) return {name, vals};
      }
    }
    return null;
  }

  const flyerRow = getVar(["Flyer"]);
  const peakRow  = getVar(["Peak Force"]);
  const workRow  = getVar(["Work Done"]);
  const startRow = getVar(["Starting Pos","Starting Position"]);
  const termRow  = getVar(["Terminal Force"]);

  if(!peakRow && !workRow && !startRow && !termRow) return null;

  const rounds = [];
  for(let i=0;i<n;i++){
    const traceName = traces[i] || `Trace ${i+1}`;
    const flyer = flyerRow ? String(flyerRow.vals[i]??"").trim().toLowerCase()==="true" : false;
    rounds.push({
      traceIndex: i+1,
      trace: traceName,
      flyerRaw: flyer,
      flyer: flyer,
      peakForce: peakRow ? toNum(peakRow.vals[i]) : null,
      workDone: workRow ? toNum(workRow.vals[i]) : null,
      startingPos: startRow ? toNum(startRow.vals[i]) : null,
      terminalForce: termRow ? toNum(termRow.vals[i]) : null,
      curve: null, // {x:[], y:[]}
      // curve features
      earlySpike: null,
      roughness: null,
      endFlat: null,
      endDrop: null,
      midSlope: null,
      // scoring
      z: {},
      score: 0,
      bucket: "normal",
      driver: "—",
      diags: [],
      cause: "—",
      conf: 0
    });
  }
  return {rounds, map, n};
}

function parseCurveBlock(block){
  // Expect header row with first col like Position/Depth and trace columns after
  const header = block[0].map(x => String(x??"").trim());
  const traceCols = detectTraceHeader(header);
  if(!traceCols.length) return null;

  // find x column: prefer first col if it contains 'pos'/'depth' or has numeric rows
  let xIdx = 0;
  for(let i=0;i<header.length;i++){
    const h = header[i].toLowerCase();
    if(h.includes('pos') || h.includes('depth') || h.includes('mm') || h.includes('in')) { xIdx=i; break; }
  }

  const xs = [];
  const ysByTrace = traceCols.map(()=>[]);
  for(let r=1;r<block.length;r++){
    const x = toNum(block[r][xIdx]);
    if(!Number.isFinite(x)) continue;
    xs.push(x);
    traceCols.forEach((tc,ti)=>{
      ysByTrace[ti].push(toNum(block[r][tc.i]));
    });
  }
  if(xs.length < 10) return null;

  return {
    traces: traceCols.map(tc=>tc.name),
    x: xs,
    ysByTrace
  };
}

function computeCurveFeatures(round){
  const c = round.curve;
  if(!c || !c.y || c.y.length<10) return;
  const y = c.y.filter(v=>Number.isFinite(v));
  if(y.length<10) return;

  const n = y.length;
  const yMin = Math.min(...y), yMax = Math.max(...y);
  const range = (yMax - yMin) || 1e-9;

  const kEarly = Math.max(5, Math.floor(n*0.12));
  const kEnd   = Math.max(5, Math.floor(n*0.12));
  const early = y.slice(0, kEarly);
  const end   = y.slice(n-kEnd);

  const earlyMax = Math.max(...early);
  const overallMax = yMax;
  round.earlySpike = (overallMax>0) ? (earlyMax / overallMax) : null; // ratio

  // roughness: mean abs 2nd diff normalized by range
  let s2 = 0, cnt = 0;
  for(let i=1;i<n-1;i++){
    const d2 = (y[i+1]-2*y[i]+y[i-1]);
    s2 += Math.abs(d2);
    cnt++;
  }
  round.roughness = cnt ? (s2/cnt)/range : null;

  // endFlat: end segment amplitude small
  const endMin = Math.min(...end), endMax = Math.max(...end);
  const endAmp = (endMax-endMin)/range;
  round.endFlat = endAmp; // smaller is flatter (we will invert for z)

  // endDrop: slope of last segment (linear fit) normalized by range
  // using index as x if real x missing
  let sumX=0,sumY=0,sumXY=0,sumXX=0;
  for(let i=0;i<end.length;i++){
    const xx=i, yy=end[i];
    sumX += xx; sumY += yy; sumXY += xx*yy; sumXX += xx*xx;
  }
  const denom = (kEnd*sumXX - sumX*sumX) || 1e-9;
  const slope = (kEnd*sumXY - sumX*sumY)/denom; // units per index
  round.endDrop = slope / range; // negative means dropping

  // midSlope: slope from 10% to 60%
  const a0 = Math.floor(n*0.10);
  const a1 = Math.floor(n*0.60);
  const mid = y.slice(a0, Math.max(a0+5,a1));
  let sx=0, sy=0, sxy=0, sxx=0;
  for(let i=0;i<mid.length;i++){
    const xx=i, yy=mid[i];
    sx+=xx; sy+=yy; sxy+=xx*yy; sxx+=xx*xx;
  }
  const den = (mid.length*sxx - sx*sx) || 1e-9;
  const ms = (mid.length*sxy - sx*sy)/den;
  round.midSlope = ms / range; // higher => steeper
}

function buildSession(rows, filename){
  const blocks = splitBlocks(rows);
  let metric = null;
  let curve = null;

  // choose best metric block: contains Peak Force row
  for(const b of blocks){
    const m = parseMetricBlock(b);
    if(m){ metric = m; break; }
  }
  if(!metric) throw new Error("Couldn't find AMP metric rows (Peak Force/Work Done/etc).");

  // choose best curve block: numeric x + trace columns
  for(const b of blocks){
    const c = parseCurveBlock(b);
    if(c){
      // sanity: number of traces should match metric count OR at least >1
      curve = c; break;
    }
  }

  // attach curves if sizes match (by index)
  if(curve){
    // If curve traces count doesn't match, we still map by order up to min
    const mN = metric.rounds.length;
    const cN = curve.ysByTrace.length;
    const n = Math.min(mN, cN);
    for(let i=0;i<n;i++){
      metric.rounds[i].curve = {x: curve.x, y: curve.ysByTrace[i]};
      computeCurveFeatures(metric.rounds[i]);
    }
  }

  // compute stats + scores
  const rounds = metric.rounds;

  // scalar metrics
  const scalarMetrics = [
    {key:"peakForce", label:"Peak Force", w:1.00},
    {key:"workDone", label:"Work Done", w:0.85},
    {key:"startingPos", label:"Starting Pos", w:0.70},
    {key:"terminalForce", label:"Terminal Force", w:0.70}
  ];

  // curve metrics (if present)
  const curveMetrics = [
    // earlySpike higher means more spike
    {key:"earlySpike", label:"Early Spike", w:0.65, present: r=>Number.isFinite(r.earlySpike)},
    // roughness higher means more jagged
    {key:"roughness", label:"Jagged", w:0.75, present: r=>Number.isFinite(r.roughness)},
    // endFlat smaller means flatter: use inv
    {key:"endFlat", label:"End Flat", w:0.55, present: r=>Number.isFinite(r.endFlat), invert:true},
    // endDrop negative means drop: use negative to highlight drops
    {key:"endDrop", label:"End Drop", w:0.55, present: r=>Number.isFinite(r.endDrop), signed:true, negativeIsBad:true},
    {key:"midSlope", label:"Mid Slope", w:0.35, present: r=>Number.isFinite(r.midSlope)}
  ];

  // build stats
  const stats = {};
  function makeStats(key){
    const arr = rounds.map(r=>r[key]).filter(v=>Number.isFinite(v));
    const med = median(arr);
    let theMad = (med==null) ? null : mad(arr, med);
    let sd=null, mu=null;
    if(!theMad || theMad===0){
      sd = stdev(arr);
      mu = mean(arr);
    }
    return {med, mad: theMad, sd, mu};
  }

  for(const m of scalarMetrics){
    stats[m.key] = {...makeStats(m.key), label:m.label};
  }
  const hasCurves = rounds.some(r=>r.curve && r.curve.y && r.curve.y.length>=10);
  if(hasCurves){
    for(const m of curveMetrics){
      // include only if at least some values exist
      const exists = rounds.some(r=>m.present(r));
      if(!exists) continue;
      stats[m.key] = {...makeStats(m.key), label:m.label, invert: !!m.invert, signed: !!m.signed, negativeIsBad: !!m.negativeIsBad};
    }
  }

  // baseline stats (optional)
  const base = getBaselineForScoring();

  // score each round
  for(const r of rounds){
    let scoreSum=0, wSum=0;
    let driverAbs=-1, driver="—";

    // scalar z
    for(const m of scalarMetrics){
      const st = stats[m.key];
      const z = robustZ(r[m.key], st);
      r.z[m.key]=z;
      const az = Math.abs(z);
      scoreSum += m.w*az; wSum += m.w;
      if(az>driverAbs){ driverAbs=az; driver=`${m.label} (${az.toFixed(2)}σ)`; }
    }

    // curve z (with special handling)
    if(hasCurves){
      for(const m of curveMetrics){
        const st = stats[m.key];
        if(!st) continue;
        if(!m.present(r)) { r.z[m.key]=0; continue; }

        let val = r[m.key];
        // invert endFlat so "flatter" = bigger badness
        if(m.invert) val = -val;
        // for signed negative-is-bad, emphasize negative direction
        let z = robustZ(val, {...st, med: st.med!=null ? (m.invert? -st.med : st.med) : st.med});
        if(m.negativeIsBad){
          // treat positive slopes as OK, negative as bad; clamp to <=0 then take abs
          z = Math.min(0, z);
        }
        r.z[m.key]=z;
        const az = Math.abs(z);
        scoreSum += m.w*az; wSum += m.w;
        if(az>driverAbs){
          driverAbs=az;
          driver=`${m.label} (${az.toFixed(2)}σ)`;
        }
      }
    }

    // baseline comparison bump (session-wide drift)
    let baseBump = 0;
    if(base){
      // Compare key medians: peakForce, workDone, midSlope (if available)
      // If current session median is far from baseline, add small bump so it appears in summary/driver.
      const curPF = stats.peakForce.med, basePF = base.metrics?.peakForce?.med;
      if(Number.isFinite(curPF) && Number.isFinite(basePF) && basePF!==0){
        const rel = Math.abs(curPF-basePF)/Math.abs(basePF);
        if(rel>0.12) baseBump += Math.min(0.6, rel*2.0); // cap
      }
      const curWD = stats.workDone.med, baseWD = base.metrics?.workDone?.med;
      if(Number.isFinite(curWD) && Number.isFinite(baseWD) && baseWD!==0){
        const rel = Math.abs(curWD-baseWD)/Math.abs(baseWD);
        if(rel>0.12) baseBump += Math.min(0.5, rel*1.6);
      }
      const curMS = stats.midSlope?.med, baseMS = base.curves?.midSlope?.med;
      if(Number.isFinite(curMS) && Number.isFinite(baseMS) && baseMS!==0){
        const rel = Math.abs(curMS-baseMS)/Math.abs(baseMS);
        if(rel>0.15) baseBump += Math.min(0.4, rel*1.2);
      }
      if(baseBump>0 && driverAbs<1.2){
        driver = `Baseline drift (+${baseBump.toFixed(2)})`;
      }
    }

    let score = wSum>0 ? (scoreSum/wSum) : 0;
    score += baseBump;

    // flyer determination: existing Flyer row OR any metric abs(z) >= 3.5
    let computedFlyer = false;
    for(const k in r.z){
      if(Math.abs(r.z[k]) >= 3.5) { computedFlyer = true; break; }
    }
    r.flyer = r.flyerRaw || computedFlyer;
    if(r.flyer) score = Math.max(score, 3.0) + 0.55;

    r.score = score;
    r.driver = driver;
    r.bucket = clsFromScore(score);

    // diagnostics + cause labels
    assignDiagnosticsAndCause(r, hasCurves);
  }

  // session summary
  const anomCnt = rounds.filter(r=>r.score >= state.threshold).length;
  const peakArr = rounds.map(r=>r.peakForce).filter(v=>Number.isFinite(v));
  const peakMed = median(peakArr);
  const curveYes = hasCurves ? "yes" : "no";

  return {
    name: filename,
    rounds,
    stats,
    hasCurves,
    summary: { 
      n: rounds.length, 
      anomalies: anomCnt, 
      flyers: rounds.filter(r=>r.flyer).length,
      peakMed, 
      peakES: (peakArr.length ? (Math.max(...peakArr)-Math.min(...peakArr)) : null),
      workMed: median(rounds.map(r=>r.workDone).filter(v=>Number.isFinite(v))),
      roughMed: median(rounds.map(r=>r.roughness).filter(v=>Number.isFinite(v))),
      curveYes 
    }
  };
}

function assignDiagnosticsAndCause(r, hasCurves){
  const diags = [];

  // scalar triggers
  const azPeak = Math.abs(r.z.peakForce||0);
  const azWork = Math.abs(r.z.workDone||0);
  const azTerm = Math.abs(r.z.terminalForce||0);

  // curve triggers (z values computed)
  const azEarly = Math.abs(r.z.earlySpike||0);
  const azRough = Math.abs(r.z.roughness||0);
  const azFlat  = Math.abs(r.z.endFlat||0);
  const azDrop  = Math.abs(r.z.endDrop||0);

  const t = state.threshold;

  // add diag tags based on notable drivers (use fixed smaller thresholds for flags)
  if(azPeak>=2.2 || azWork>=2.2 || azTerm>=2.2) diags.push("Force outlier");
  if(hasCurves){
    if(azEarly>=2.0) diags.push("Early spike");
    if(azRough>=2.0) diags.push("Jagged");
    if(azFlat>=2.0) diags.push("End flat");
    if(azDrop>=2.0) diags.push("End drop");
  }
  if(r.flyer) diags.unshift("Flyer");

  r.diags = diags.length ? diags : ["—"];

  // probable cause mapping (pick top feature)
  const candidates = [];
  // (scoreContribution, label, confidenceHint)
  if(hasCurves && azEarly>=1.6) candidates.push([azEarly, "Case mouth / chamfer / donut", 0.70]);
  if(hasCurves && azRough>=1.6) candidates.push([azRough, "Carbon / neck-wall inconsistency / damage", 0.68]);
  if(azPeak>=1.8 || azWork>=1.8) candidates.push([Math.max(azPeak,azWork), "Neck tension / sizing / anneal variance", 0.64]);
  if(hasCurves && (azFlat>=1.8 || azDrop>=1.8)) candidates.push([Math.max(azFlat,azDrop), "Bearing-surface transition or seating setup inconsistency", 0.55]);

  // baseline drift could be session-wide; for per-round we keep cause from z.
  candidates.sort((a,b)=>b[0]-a[0]);

  if(!candidates.length){
    r.cause = "—";
    r.conf = 0;
    return;
  }

  const [topZ, cause, baseConf] = candidates[0];
  // confidence: scale with severity, capped
  let conf = Math.min(0.95, baseConf + Math.max(0, (topZ-2.0))*0.08);
  if(r.flyer) conf = Math.min(0.98, conf + 0.08);
  r.cause = cause;
  r.conf = conf;
}

/* ========== baseline storage ========== */
const BASE_KEY = "amp_diag_baseline_v1";
function loadBaseline(){
  try{
    const s = localStorage.getItem(BASE_KEY);
    if(!s) return null;
    return JSON.parse(s);
  }catch(e){ return null; }
}
function saveBaseline(obj){
  try{ localStorage.setItem(BASE_KEY, JSON.stringify(obj)); }catch(e){}
}
function clearBaseline(){
  try{ localStorage.removeItem(BASE_KEY); }catch(e){}
}
function getBaselineForScoring(){
  if(state.baselineMode==="none") return null;
  if(state.baselineMode==="active"){
    const sess = state.sessions[state.activeIndex];
    if(!sess) return null;
    return sessionToBaseline(sess);
  }
  if(state.baselineMode==="custom"){
    return state.baseline || null;
  }
  return null;
}
function sessionToBaseline(sess){
  const b = {metrics:{}, curves:{}};
  // store medians
  for(const k of ["peakForce","workDone","startingPos","terminalForce"]){
    const st = sess.stats?.[k];
    if(st && st.med!=null) b.metrics[k]={med:st.med};
  }
  for(const k of ["earlySpike","roughness","endFlat","endDrop","midSlope"]){
    const st = sess.stats?.[k];
    if(st && st.med!=null) b.curves[k]={med:st.med};
  }
  return b;
}

/* ========== rendering ========== */

function recomputeSessionPostFlags(sess){
  // tags: top5/bottom5 by Peak Force; ES-based exclusion of extremes
  if(!sess || !sess.rounds) return sess;
  const rounds = sess.rounds;
  // clear prior tags/exclusions that are derived
  for(const r of rounds){
    r.tag = "";
    r.excluded = false;
    r.flags = (r.flags && Array.isArray(r.flags)) ? r.flags.filter(f=>!f.startsWith("ES ") && f!=="Top5" && f!=="Bottom5") : [];
    // keep diag list but remove ES breach / tags (we'll re-add)
    if(r.diags && Array.isArray(r.diags)){
      r.diags = r.diags.filter(d=>d!=="ES breach" && d!=="Top5" && d!=="Bottom5");
    }
  }

  const peakPairs = rounds
    .map((r,i)=>({i, v:r.peakForce}))
    .filter(o=>Number.isFinite(o.v))
    .sort((a,b)=>b.v-a.v);

  // Tag top/bottom 5 (or fewer if small session)
  const k = Math.min(5, peakPairs.length);
  for(let j=0;j<k;j++){
    const topIdx = peakPairs[j].i;
    const botIdx = peakPairs[peakPairs.length-1-j].i;
    const rt = rounds[topIdx];
    const rb = rounds[botIdx];
    if(rt){
      rt.tag = rt.tag ? (rt.tag+";Top5") : "Top5";
      rt.flags = rt.flags || [];
      rt.flags.push("Top5");
    }
    if(rb){
      rb.tag = rb.tag ? (rb.tag+";Bottom5") : "Bottom5";
      rb.flags = rb.flags || [];
      rb.flags.push("Bottom5");
    }
  }

  // Session ES (Peak Force)
  const peaks = peakPairs.map(o=>o.v);
  const peakES = peaks.length ? (peaks[0]-peaks[peaks.length-1]) : null;
  sess.summary.peakES = peakES;

  // Auto-exclude extremes when ES exceeds limit
  if(state.esAutoExclude && Number.isFinite(peakES) && peakES > state.esLimit && peakPairs.length){
    const maxIdx = peakPairs[0].i;
    const minIdx = peakPairs[peakPairs.length-1].i;
    for(const idx of [maxIdx, minIdx]){
      const r = rounds[idx];
      if(!r) continue;
      r.excluded = true;
      r.flags = r.flags || [];
      r.flags.push(`ES > ${state.esLimit}lb`);
      if(r.diags && Array.isArray(r.diags)){
        if(!r.diags.includes("ES breach")) r.diags.unshift("ES breach");
      }else{
        r.diags = ["ES breach"];
      }
      // Treat as high anomaly driver for review without forcing Flyer
      r.score = Math.max(r.score, state.threshold + 0.15);
      r.bucket = clsFromScore(r.score);
    }
  }
  return sess;
}

function renderSessionOptions(){
  els.sessionSel.innerHTML = "";
  state.sessions.forEach((s, idx)=>{
    const opt = document.createElement('option');
    opt.value = String(idx);
    opt.textContent = `${s.name} (${s.summary.n} rounds)`;
    els.sessionSel.appendChild(opt);
  });
  els.sessionSel.value = String(state.activeIndex || 0);
}
function getActiveSession(){ return state.sessions[state.activeIndex] || null; }
function renderSessionsView(){
  // ensure summaries up to date
  state.sessions.forEach(s=>recomputeSessionPostFlags(s));
  if(!state.sessions.length){
    els.sessionsWrap.style.display='none';
    return;
  }
  const rows = state.sessions.map((s,idx)=>({
    idx,
    name:s.name,
    n:s.summary.n,
    flyers:s.rounds.filter(r=>r.flyer).length,
    anomalies:s.rounds.filter(r=>r.score>=state.threshold).length,
    peakMed:s.summary.peakMed,
    peakES:s.summary.peakES,
    workMed:s.summary.workMed,
    roughMed:s.summary.roughMed
  }));

  // draw chart (median peak + ES)
  drawSessionChart(rows);

  els.sessionsTbody.innerHTML = rows.map(r=>{
    return `<tr data-idx="${r.idx}">
      <td title="${escapeHtml(r.name)}">${escapeHtml(r.name)}</td>
      <td class="mono">${r.n}</td>
      <td class="mono">${r.flyers}</td>
      <td class="mono">${r.anomalies}</td>
      <td class="mono">${r.peakMed==null?'—':fmt(r.peakMed,2)}</td>
      <td class="mono">${r.peakES==null?'—':fmt(r.peakES,1)}</td>
      <td class="mono">${r.workMed==null?'—':fmt(r.workMed,2)}</td>
      <td class="mono">${r.roughMed==null?'—':fmt(r.roughMed,4)}</td>
    </tr>`;
  }).join("");

  // click handler
  Array.from(els.sessionsTbody.querySelectorAll('tr')).forEach(tr=>{
    tr.addEventListener('click', ()=>{
      const idx = Number(tr.getAttribute('data-idx'));
      if(Number.isFinite(idx)){
        state.activeIndex = idx;
        renderSessionOptions();
        // switch back to rounds view
        state.view='rounds';
        els.tabRounds.classList.add('active'); els.tabSessions.classList.remove('active');
        els.sessionsWrap.style.display='none';
        els.tableWrap.style.display='block';
        render();
      }
    });
  });
}

function drawSessionChart(rows){
  const c = els.sessChart;
  if(!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);

  // compute scales
  const medVals = rows.map(r=>r.peakMed).filter(v=>Number.isFinite(v));
  const esVals = rows.map(r=>r.peakES).filter(v=>Number.isFinite(v));
  if(!medVals.length && !esVals.length){
    ctx.fillStyle = 'rgba(255,255,255,.55)';
    ctx.font = '14px ui-sans-serif';
    ctx.fillText('No chartable values (need Peak Force values).', 12, 22);
    return;
  }
  const xPad=28, yPad=18, plotW=W-xPad*2, plotH=H-yPad*2;
  const minMed=Math.min(...medVals), maxMed=Math.max(...medVals);
  const minES=esVals.length?Math.min(...esVals):0, maxES=esVals.length?Math.max(...esVals):1;

  function x(i){ return xPad + (rows.length<=1? 0 : (i/(rows.length-1))*plotW); }
  function yMed(v){
    if(!Number.isFinite(v)) return null;
    const t = (v-minMed)/((maxMed-minMed)||1);
    return yPad + (1-t)*plotH;
  }
  function yES(v){
    if(!Number.isFinite(v)) return null;
    const t = (v-minES)/((maxES-minES)||1);
    return yPad + (1-t)*plotH;
  }

  // axes
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(xPad, yPad);
  ctx.lineTo(xPad, yPad+plotH);
  ctx.lineTo(xPad+plotW, yPad+plotH);
  ctx.stroke();

  // line: med
  ctx.strokeStyle = 'rgba(124,220,255,.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  let started=false;
  rows.forEach((r,i)=>{
    const yy=yMed(r.peakMed);
    if(yy==null) return;
    const xx=x(i);
    if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // points: med
  ctx.fillStyle = 'rgba(124,220,255,.95)';
  rows.forEach((r,i)=>{
    const yy=yMed(r.peakMed); if(yy==null) return;
    const xx=x(i);
    ctx.beginPath(); ctx.arc(xx,yy,3,0,Math.PI*2); ctx.fill();
  });

  // line: ES
  ctx.strokeStyle = 'rgba(255,184,124,.75)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  started=false;
  rows.forEach((r,i)=>{
    const yy=yES(r.peakES);
    if(yy==null) return;
    const xx=x(i);
    if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // points: ES
  ctx.fillStyle = 'rgba(255,184,124,.9)';
  rows.forEach((r,i)=>{
    const yy=yES(r.peakES); if(yy==null) return;
    const xx=x(i);
    ctx.beginPath(); ctx.arc(xx,yy,3,0,Math.PI*2); ctx.fill();
  });

  // labels
  ctx.fillStyle = 'rgba(255,255,255,.55)';
  ctx.font = '12px ui-sans-serif';
  ctx.fillText('Peak Med', xPad+6, yPad+12);
  ctx.fillText('Peak ES', xPad+80, yPad+12);
}


function setupHeaderSort(){
  const headerMap = new Map([
    ["Trace","traceIndex"],
    ["Flyer","flyer"],
    ["Excluded","excluded"],
    ["Tag","tag"],
    ["Cause","cause"],
    ["Conf","conf"],
    ["Score","score"],
    ["Peak Force","peakForce"],
    ["Work Done","workDone"],
    ["Starting Pos","startingPos"],
    ["Terminal Force","terminalForce"],
    ["Early Spike","earlySpike"],
    ["Jagged","roughness"],
    ["End Flat","endFlat"],
    ["End Drop","endDrop"]
  ]);
  const ths = document.querySelectorAll("#tableWrap thead th");
  ths.forEach(th=>{
    const label = (th.textContent||"").trim();
    const field = headerMap.get(label);
    if(!field) return;
    th.style.cursor = "pointer";
    th.title = "Click to sort";
    th.addEventListener("click", ()=>{
      // toggle
      if(state.sortField === field){
        state.sortDir = (state.sortDir === "asc") ? "desc" : "asc";
      } else {
        state.sortField = field;
        // default directions: numeric desc, booleans true-first, strings asc
        const numericFields = new Set(["traceIndex","score","peakForce","workDone","startingPos","terminalForce","earlySpike","roughness","endFlat","endDrop","conf"]);
        if(numericFields.has(field)) state.sortDir = (field==="traceIndex") ? "asc" : "desc";
        else state.sortDir = "asc";
      }
      // mark sort mode
      state.sort = 'custom';
      if(els.sortSel) els.sortSel.value = 'custom';
      // visual hint
      ths.forEach(x=>x.classList.remove("sortedAsc","sortedDesc"));
      th.classList.add(state.sortDir==="asc" ? "sortedAsc" : "sortedDesc");
      render();
    });
  });
}

function exportSessionsCSV(){
  const csvCellLocal = (v)=>{
    let s = (v==null) ? "" : String(v);
    if(/[",\n]/.test(s)) s = `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const header = ["Session","Rounds","Flyers","Anomalies","Peak Med","Peak ES","Work Med","Rough Med"];
  const lines = [header.join(",")];
  for(const s of state.sessions){
    const row = [
      s.name,
      s.summary.n,
      s.rounds.filter(r=>r.flyer).length,
      s.rounds.filter(r=>r.score>=state.threshold).length,
      s.summary.peakMed==null? "": s.summary.peakMed,
      s.summary.peakES==null? "": s.summary.peakES,
      s.summary.workMed==null? "": s.summary.workMed,
      s.summary.roughMed==null? "": s.summary.roughMed
    ].map(csvCellLocal).join(",");
    lines.push(row);
  }
  const blob = new Blob([lines.join("\n")], {type:"text/csv"});
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url;
  a.download = "amp_sessions_summary.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}


function matchesQuery(r, q){
  if(!q) return true;
  q = q.toLowerCase();
  return (
    String(r.trace).toLowerCase().includes(q) ||
    String(r.driver).toLowerCase().includes(q) ||
    String(r.cause).toLowerCase().includes(q) ||
    String(r.diags.join(" ")).toLowerCase().includes(q)
  );
}

function renderTraceChart(){
  const c = els.traceChart;
  if(!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);

  const sess = getActiveSession();
  if(!sess || !sess.rounds || !sess.rounds.length){
    ctx.fillStyle = 'rgba(255,255,255,.55)';
    ctx.font = '14px ui-sans-serif';
    ctx.fillText('Load a session to see the trace chart.', 12, 22);
    return;
  }

  let rounds = (state.traceChart && state.traceChart.useFiltered) ? (state.shownRows||[]) : sess.rounds.slice();
  if(!(state.traceChart && state.traceChart.showExcluded)){
    rounds = rounds.filter(r=>!r.excluded);
  }
  drawTraceChart(rounds, {overlayWork: !!(state.traceChart && state.traceChart.overlayWork)});
}

function drawTraceChart(rounds, opts){
  const c = els.traceChart;
  if(!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);

  const peak = rounds.map(r=>r.peakForce).filter(v=>Number.isFinite(v));
  if(!peak.length){
    ctx.fillStyle = 'rgba(255,255,255,.55)';
    ctx.font = '14px ui-sans-serif';
    ctx.fillText('No Peak Force values to chart.', 12, 22);
    return;
  }
  const work = rounds.map(r=>r.workDone).filter(v=>Number.isFinite(v));
  const overlayWork = !!opts.overlayWork && work.length>1;

  const xPad=34, yPad=18, plotW=W-xPad*2, plotH=H-yPad*2;

  const minX = Math.min(...rounds.map(r=>r.traceIndex||0)), maxX = Math.max(...rounds.map(r=>r.traceIndex||0));
  const minP = Math.min(...peak), maxP = Math.max(...peak);
  const pPad = (maxP-minP)*0.08 || 1;
  const yMinP = minP - pPad, yMaxP = maxP + pPad;

  let yMinW=0, yMaxW=1;
  if(overlayWork){
    const minW=Math.min(...work), maxW=Math.max(...work);
    const wPad=(maxW-minW)*0.08 || 0.01;
    yMinW=minW-wPad; yMaxW=maxW+wPad;
  }

  const x = (xi)=>{
    const t = (xi-minX)/((maxX-minX)||1);
    return xPad + t*plotW;
  };
  const yP = (v)=>{
    const t = (v-yMinP)/((yMaxP-yMinP)||1);
    return yPad + (1-t)*plotH;
  };
  const yW = (v)=>{
    const t = (v-yMinW)/((yMaxW-yMinW)||1);
    return yPad + (1-t)*plotH;
  };

  // axes
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(xPad, yPad);
  ctx.lineTo(xPad, yPad+plotH);
  ctx.lineTo(xPad+plotW, yPad+plotH);
  ctx.stroke();

  // y labels (minimal)
  ctx.fillStyle = 'rgba(255,255,255,.45)';
  ctx.font = '12px ui-sans-serif';
  ctx.fillText('Peak', 8, 22);
  if(overlayWork) ctx.fillText('Work', 8, 38);

  // Peak line
  ctx.strokeStyle = 'rgba(124,220,255,.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  let started=false;
  rounds.slice().sort((a,b)=>(a.traceIndex||0)-(b.traceIndex||0)).forEach((r)=>{
    if(!Number.isFinite(r.peakForce)) return;
    const xx=x(r.traceIndex||0), yy=yP(r.peakForce);
    if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // Work line (optional)
  if(overlayWork){
    ctx.strokeStyle = 'rgba(255,180,92,.78)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    started=false;
    rounds.slice().sort((a,b)=>(a.traceIndex||0)-(b.traceIndex||0)).forEach((r)=>{
      if(!Number.isFinite(r.workDone)) return;
      const xx=x(r.traceIndex||0), yy=yW(r.workDone);
      if(!started){ ctx.moveTo(xx,yy); started=true; } else ctx.lineTo(xx,yy);
    });
    ctx.stroke();
  }

  // Points / highlights
  rounds.forEach((r)=>{
    const xi=r.traceIndex||0;
    if(!Number.isFinite(r.peakForce)) return;
    const xx=x(xi), yy=yP(r.peakForce);

    // base style
    let fill='rgba(124,220,255,.92)';
    let stroke=null, lw=2, rad=4;

    if(r.excluded){
      fill='rgba(200,200,210,.55)';
      rad=3.5;
    }
    if(r.tag==="Top5"){
      fill='rgba(96,205,255,.95)';
      rad=5;
    }else if(r.tag==="Bottom5"){
      fill='rgba(120,255,170,.92)';
      rad=5;
    }
    if(r.flyer){
      stroke='rgba(255,90,90,.95)';
      lw=2.5;
      rad=5.5;
    }

    ctx.beginPath();
    ctx.arc(xx,yy,rad,0,Math.PI*2);
    ctx.fillStyle=fill;
    ctx.fill();
    if(stroke){
      ctx.strokeStyle=stroke;
      ctx.lineWidth=lw;
      ctx.stroke();
    }
  });

  // Legend (tiny)
  ctx.fillStyle='rgba(255,255,255,.52)';
  ctx.font='12px ui-sans-serif';
  ctx.fillText('Peak Force', xPad+8, yPad+14);
  if(overlayWork) ctx.fillText('Work Done', xPad+92, yPad+14);
}


function sortRounds(a,b){
  // Header-click sort takes precedence
  if(state.sortField){
    const f = state.sortField;
    const dir = state.sortDir === "asc" ? 1 : -1;
    const av = a[f];
    const bv = b[f];
    // booleans
    if(typeof av === "boolean" || typeof bv === "boolean"){
      const aa = av ? 1 : 0;
      const bb = bv ? 1 : 0;
      return (aa - bb) * dir;
    }
    // numbers
    if(Number.isFinite(av) || Number.isFinite(bv)){
      const aa = Number.isFinite(av) ? av : -1e18;
      const bb = Number.isFinite(bv) ? bv : -1e18;
      return (aa - bb) * dir;
    }
    // strings
    const aa = (av==null) ? "" : String(av);
    const bb = (bv==null) ? "" : String(bv);
    return aa.localeCompare(bb) * dir;
  }

  const key = state.sort;
  if(key==="score_desc") return b.score - a.score;
  if(key==="score_asc") return a.score - b.score;
  if(key==="trace_asc") return a.traceIndex - b.traceIndex;
  if(key==="trace_desc") return b.traceIndex - a.traceIndex;
  if(key==="peak_desc") return (b.peakForce??-1e9) - (a.peakForce??-1e9);
  if(key==="work_desc") return (b.workDone??-1e9) - (a.workDone??-1e9);
  if(key==="rough_desc") return (b.roughness??-1e9) - (a.roughness??-1e9);
  return b.score - a.score;
}
function confLabel(c){
  if(!Number.isFinite(c) || c<=0) return "—";
  if(c>=0.85) return "high";
  if(c>=0.65) return "med";
  return "low";
}

function diagTip(label){
  const m = {
    "Flyer":"Flyer: this trace is a mechanical outlier vs the session baseline (robust outlier test). Consider segregating or re-prepping.",
    "Force outlier":"Force outlier: Peak Force / Work / Position deviates strongly from the session median (robust z-score).",
    "Early spike":"Early spike: unusually high resistance early in seating (possible rough mouth, insufficient chamfer, or neck donut contact).",
    "Jagged":"Jagged: high curve roughness (possible carbon, inconsistent neck wall, corrosion, or damage).",
    "End flat":"End flat: reduced slope near end of seating (often normal bearing-surface behavior; watch consistency).",
    "End drop":"End drop: downward trend at end of seating (often normal; can indicate transition in bearing surface contact)."
  };
  if(m[label]) return m[label];
  if(label && label.startsWith("End")) return "End-of-stroke feature: compare consistency across the batch.";
  if(label && label.includes("ES")) return "ES rule: batch extreme spread exceeded the configured limit.";
  return "Diagnostic flag";
}
function tagTip(tag){
  if(tag==="Top5") return "Top5: one of the five HIGHEST Peak Force traces in this session (by Peak Force).";
  if(tag==="Bottom5") return "Bottom5: one of the five LOWEST Peak Force traces in this session (by Peak Force).";
  return "Tag";
}
function diagBadges(r){
  const parts = (r.diags||[]).slice();
  const flags = (r.flags||[]);
  for(const f of flags){ if(f==="Top5"||f==="Bottom5") continue; if(!parts.includes(f)) parts.push(f); }
  const out = parts.map(p=>{
    const dot = p==="Flyer" ? "bad" :
                p==="Force outlier" ? "warn" :
                (p==="Early spike" || p==="Jagged" || p.startsWith("End")) ? "mid" :
                "good";
    return `<span class="badge" title="${escapeHtml(diagTip(p))}"><span class="dot ${dot}"></span>${escapeHtml(p)}</span>`;
  });
  return out.join(" ");
}

function render(){
  const sess = getActiveSession();
  if(!sess){
    els.empty.style.display="block";
    els.tableWrap.style.display="none";
    els.kN.textContent="—"; els.kA.textContent="—"; els.kPF.textContent="—"; els.kCurve.textContent="—";
    els.sessLabel.textContent="—"; els.sessLabel.title="—"; els.sessMeta.textContent="—";
    els.curveChip.textContent="Curve: —";
    els.baseChip.textContent = `Baseline: ${state.baselineMode}`;
    els.showChip.textContent = "Shown: —";
    return;
  }

  els.empty.style.display="none";
  els.tableWrap.style.display="block";

  // header label (ellipsis)
  els.sessLabel.textContent = sess.name;
  els.sessLabel.title = sess.name;
  els.sessMeta.textContent = `${sess.summary.n} rounds • ${sess.summary.anomalies} anomalies • ${sess.summary.flyers||0} flyers • Peak ES ${(sess.summary.peakES==null?'—':fmt(sess.summary.peakES,1))}lb`;
  els.curveChip.textContent = `Curve: ${sess.hasCurves ? "yes" : "no"}`;
  els.baseChip.textContent = `Baseline: ${state.baselineMode === "custom" ? (state.baseline ? "saved" : "none") : state.baselineMode}`;
  els.kN.textContent = sess.summary.n;
  els.kA.textContent = sess.rounds.filter(r=>r.score>=state.threshold).length;
  els.kPF.textContent = (sess.summary.peakMed==null) ? "—" : fmt(sess.summary.peakMed,3);
  els.kCurve.textContent = sess.hasCurves ? "yes" : "no";

  // sync trace chart controls
  if(els.tcOverlayWork) els.tcOverlayWork.checked = !!state.traceChart.overlayWork;
  if(els.tcUseFiltered) els.tcUseFiltered.checked = !!state.traceChart.useFiltered;
  if(els.tcShowExcluded) els.tcShowExcluded.checked = !!state.traceChart.showExcluded;

  const rows = sess.rounds
    .filter(r=>(!state.onlyAnom || r.score>=state.threshold))
    .filter(r=>(!state.hideExcluded || !r.excluded))
    .filter(r=>matchesQuery(r, state.query))
    .slice()
    .sort(sortRounds);

  state.shownRows = rows;
  els.showChip.textContent = `Shown: ${rows.length}`;

  const body = rows.map(r=>{
    const cls = clsFromScore(r.score);
    const flyerTxt = r.flyer ? "true" : "false";
    const conf = confLabel(r.conf);
    const early = r.earlySpike!=null ? fmt(r.earlySpike,3) : "—";
    const rough = r.roughness!=null ? fmt(r.roughness,4) : "—";
    const flat  = r.endFlat!=null ? fmt(r.endFlat,4) : "—";
    const drop  = r.endDrop!=null ? fmt(r.endDrop,4) : "—";
    const exTxt = r.excluded ? "true" : "false";
    const tagHtml = (r.tag ? r.tag.split(";").filter(Boolean) : []).map(tg=>{
      const tip = (tg==="Top5") ? "Tag: one of the five HIGHEST Peak Force traces in this session"
                : (tg==="Bottom5") ? "Tag: one of the five LOWEST Peak Force traces in this session"
                : "Tag";
      const dot = (tg==="Top5") ? "good" : (tg==="Bottom5") ? "mid" : "warn";
      return `<span class="badge" title="${escapeHtml(tip)}"><span class="dot ${dot}"></span>${escapeHtml(tg)}</span>`;
    }).join(" ") || "—";
    return `<tr class="${cls} ${r.excluded?'excluded':''}">
      <td class="mono">${escapeHtml(r.trace)}</td>
      <td><span class="badge" title="Flyer: mechanical outlier vs session baseline (force/position/work)."><span class="dot ${r.flyer?'bad':'good'}"></span>${flyerTxt}</span></td>
      <td><span class="badge" title="Excluded: removed by ES rule or manual exclusion; still tracked for review/export."><span class="dot ${r.excluded?'warn':'good'}"></span>${exTxt}</span></td>
      <td>${tagHtml}</td>
      <td>${diagBadges(r)}</td>
      <td>${escapeHtml(r.cause)}</td>
      <td><span class="badge" title="Confidence: how strongly the data supports the Cause label."><span class="dot ${conf==='high'?'bad':conf==='med'?'warn':conf==='low'?'mid':'good'}"></span>${conf}</span></td>
      <td class="mono">${fmt(r.score,2)}</td>
      <td>${escapeHtml(r.driver)}</td>
      <td class="mono">${fmt(r.peakForce,3)}</td>
      <td class="mono">${fmt(r.workDone,3)}</td>
      <td class="mono">${fmt(r.startingPos,3)}</td>
      <td class="mono">${fmt(r.terminalForce,3)}</td>
      <td class="mono">${early}</td>
      <td class="mono">${rough}</td>
      <td class="mono">${flat}</td>
      <td class="mono">${drop}</td>
    </tr>`;
  }).join("");

  els.tbody.innerHTML = body;
  renderTraceChart();
}

/* ========== export ========== */
function csvCell(v){
  const s = String(v ?? "");
  if(/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
  return s;
}
function exportShown(){
  const rows = state.shownRows || [];
  if(!rows.length) return;
  const header = ["Session","Trace","Flyer","Excluded","Tag","Bucket","Score","Driver","Why","Cause","Confidence",
    "Peak Force","Work Done","Starting Pos","Terminal Force","Early Spike","Jaggedness","End Flat","End Drop"];
  const lines = [header.join(",")];
  const sess = getActiveSession();
  for(const r of rows){
    lines.push([
      sess ? sess.name : "",
      r.trace, r.flyer ? "true":"false", (r.excluded?"true":"false"), (r.tag||""), clsFromScore(r.score), fmt(r.score,2), r.driver,
      ((r.diags||[]).concat(r.flags||[])).filter((v,i,a)=>a.indexOf(v)===i).join("; "),
      r.cause,
      confLabel(r.conf),
      r.peakForce ?? "", r.workDone ?? "", r.startingPos ?? "", r.terminalForce ?? "",
      r.earlySpike ?? "", r.roughness ?? "", r.endFlat ?? "", r.endDrop ?? ""
    ].map(csvCell).join(","));
  }
  const blob = new Blob([lines.join("\n")], {type:"text/csv"});
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url;
  a.download = `amp_anomalies_${(sess?sess.name:"session").replace(/[^\w\-]+/g,'_').slice(0,60)}.csv`;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}

/* ========== file loading ========== */
async function loadFiles(fileList){
  const files = Array.from(fileList || []);
  if(!files.length) return;
  const newSessions = [];
  for(const f of files){
    const txt = await f.text();
    const rows = parseCSV(txt);
    try{
      const sess = buildSession(rows, f.name);
      newSessions.push(sess);
    }catch(e){
      console.warn("Parse failed", f.name, e);
      alert(`Parse failed for ${f.name}:\n${e.message || e}`);
    }
  }
  if(!newSessions.length) return;
  newSessions.forEach(s=>recomputeSessionPostFlags(s));
  state.sessions = state.sessions.concat(newSessions);
  state.activeIndex = state.sessions.length - newSessions.length; // jump to first newly added
  renderSessionOptions();
  render();
}

/* ========== wiring ========== */
els.fileIn.addEventListener('change', (e)=>loadFiles(e.target.files));

els.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); els.drop.style.filter="brightness(1.1)"; });
els.drop.addEventListener('dragleave', ()=>{ els.drop.style.filter=""; });
els.drop.addEventListener('drop', (e)=>{
  e.preventDefault(); els.drop.style.filter="";
  loadFiles(e.dataTransfer.files);
});

els.sessionSel.addEventListener('change', ()=>{
  state.activeIndex = Number(els.sessionSel.value)||0;
  // recompute scores because threshold might change (flyer already done)
  render();
});
els.th.addEventListener('input', ()=>{
  state.threshold = Number(els.th.value);
  els.thVal.textContent = state.threshold.toFixed(2);
  render();
});

els.es.addEventListener('input', ()=>{
  state.esLimit = Number(els.es.value);
  els.esVal.textContent = String(state.esLimit);
  // recompute ES exclusions/tags for all sessions
  state.sessions = state.sessions.map(s=>recomputeSessionPostFlags(s));
  render();
});
els.esAuto.addEventListener('change', ()=>{
  state.esAutoExclude = els.esAuto.checked;
  state.sessions = state.sessions.map(s=>recomputeSessionPostFlags(s));
  render();
});
els.hideEx.addEventListener('change', ()=>{
  state.hideExcluded = els.hideEx.checked;
  render();
});
els.tabRounds.addEventListener('click', ()=>{
  state.view='rounds';
  els.tabRounds.classList.add('active'); els.tabSessions.classList.remove('active');
  els.tableWrap.style.display = (getActiveSession() ? 'block':'none');
  els.sessionsWrap.style.display = 'none';
});
els.tabSessions.addEventListener('click', ()=>{
  state.view='sessions';
  els.tabSessions.classList.add('active'); els.tabRounds.classList.remove('active');
  els.sessionsWrap.style.display = (state.sessions.length ? 'block':'none');
  els.tableWrap.style.display = 'none';
  renderSessionsView();
});
els.btnExportSessions.addEventListener('click', exportSessionsCSV);

// Trace chart controls
if(els.tcOverlayWork) els.tcOverlayWork.addEventListener('change', ()=>{ state.traceChart.overlayWork = els.tcOverlayWork.checked; renderTraceChart(); });
if(els.tcUseFiltered) els.tcUseFiltered.addEventListener('change', ()=>{ state.traceChart.useFiltered = els.tcUseFiltered.checked; renderTraceChart(); });
if(els.tcShowExcluded) els.tcShowExcluded.addEventListener('change', ()=>{ state.traceChart.showExcluded = els.tcShowExcluded.checked; renderTraceChart(); });


els.onlyAnom.addEventListener('change', ()=>{ state.onlyAnom = els.onlyAnom.checked; render(); });
els.q.addEventListener('input', ()=>{ state.query = els.q.value.trim(); render(); });
els.sortSel.addEventListener('change', ()=>{
  const v = els.sortSel.value;
  if(v === 'custom'){
    // Only meaningful if a header sort is active
    if(!state.sortField){
      // revert to previous non-custom choice
      els.sortSel.value = state.sort && state.sort !== 'custom' ? state.sort : 'score_desc';
    } else {
      state.sort = 'custom';
    }
    render();
    return;
  }
  state.sort = v;
  state.sortField = null;
  state.sortDir = null;
  document.querySelectorAll('th').forEach(x=>x.classList.remove('sortedAsc','sortedDesc'));
  render();
});

els.baseSel.addEventListener('change', ()=>{
  state.baselineMode = els.baseSel.value;
  render();
});
els.btnSaveBase.addEventListener('click', ()=>{
  const sess = getActiveSession();
  if(!sess) return;
  state.baseline = sessionToBaseline(sess);
  saveBaseline(state.baseline);
  state.baselineMode = "custom";
  els.baseSel.value = "custom";
  render();
});
els.btnClrBase.addEventListener('click', ()=>{
  state.baseline = null;
  clearBaseline();
  if(state.baselineMode==="custom"){
    state.baselineMode = "none";
    els.baseSel.value = "none";
  }
  render();
});

els.btnExport.addEventListener('click', exportShown);
els.btnClear.addEventListener('click', ()=>{
  state.sessions = [];
  state.activeIndex = 0;
  els.sessionSel.innerHTML="";
  render();
});

/* ========== init baseline + render ========== */
state.baseline = loadBaseline();
setupHeaderSort();
render();

// Small hint to show injection warning if console shows the secdomcheck pattern
(function(){
  const orig = console.error;
  console.error = function(...args){
    try{
      const s = args.map(a=>String(a)).join(" ");
      if(s.includes("secdomcheck.online") || s.includes("doubleview.online") || s.includes("topodat.info")){
        els.injWarn.style.display="block";
      }
    }catch(e){}
    return orig.apply(console, args);
  };
})();
</script>
</body>
</html>
